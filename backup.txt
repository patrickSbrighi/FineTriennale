\documentclass[12pt,a4paper,openright,twoside]{book}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel} % Aggiunto per la sillabazione italiana
\usepackage{disi-thesis}
\usepackage{code-lstlistings}
\usepackage{notes}
\usepackage{shortcuts}
\usepackage{acronym}
\usepackage{caption}

\school{\unibo}
\programme{Corso di Laurea in Ingegneria e Scienze Informatiche}
\title{Oltre la Blockchain: Pagamenti Off-Chain e Lightning Network tra Scalabilità e Sicurezza}
\author{Patrick Sbrighi}
\date{\today}
\subject{Crittografia}
\supervisor{Prof. Luciano Margara}
\session{III}
\academicyear{2024-2025}

% Definizione Acronimi
\acrodef{HTLC}{Hashed Time-Lock Contract}
\acrodef{PoW}{Proof-of-Work}
\acrodef{LN}{Lightning Network}

\mainlinespacing{1.241}

\begin{document}

\frontmatter\frontispiece

\begin{abstract}	
Questa tesi analizza il Lightning Network come soluzione al problema della scalabilità delle blockchain pubbliche, con particolare attenzione agli aspetti architetturali e di sicurezza. L’obiettivo è fornire una panoramica chiara dei meccanismi principali, evidenziandone vantaggi, limiti e possibili sviluppi futuri.
\end{abstract}

%----------------------------------------------------------------------------------------
\tableofcontents   
%----------------------------------------------------------------------------------------

\mainmatter

%----------------------------------------------------------------------------------------
\chapter*{Introduzione}
\addcontentsline{toc}{chapter}{Introduzione}
%----------------------------------------------------------------------------------------
Con la pubblicazione del whitepaper su Bitcoin da parte di Satoshi Nakamoto\cite{nakamoto2008bitcoin}, viene per la prima volta presentata la blockchain, una tecnologia innovativa che ha ridefinito le fondamenta dei sistemi distribuiti. Sfruttando tale innovazione viene mostrata la possibilità di trasferire valore su scala globale senza la necessità di intermediari fiduciari o autorità centrali. Questa architettura non rappresenta solamente un avanzamento a livello informatico, ma simboleggia anche un cambiamento sociale ed economico, infatti, per la prima volta, la fiducia viene spostata dalle istituzioni agli algoritmi crittografici, permettendo alle parti di cooperare direttamente senza la necessità di conoscersi e fidarsi reciprocamente.

Tuttavia, questo sistema si basa su un registro distribuito mantenuto da una rete peer-to-peer, dove il consenso sullo stato dei fondi viene raggiunto attraverso un protocollo di gossip che diffonde in broadcast ogni transazione a tutti i partecipanti della rete. Tale approccio, sebbene garantisca sicurezza e decentralizzazione, impone pesanti limiti per quanto riguarda la capacità del sistema di gestire elevate quantità di transazioni.

Nello schema originale di Bitcoin ciascun nodo deve validare e memorizzare ogni transazione che avviene a livello globale, il problema principale, infatti, risiede proprio in questo. Se si verificasse un aumento smisurato del numero di transazioni il sistema crollerebbe, mentre se si aumentasse dimensione dei blocchi per inglobare più transazioni verrebbero richieste risorse computazionali e di archiviazione tali da escludere la maggior parte dei nodi domestici, portando inevitabilmente a una centralizzazione dei validatori e minando la natura trustless e decentralizzata del sistema.

Per ovviare a tale problema, e superare quello che verrà definito come "trilemma della scalabilità", è emersa la necessità di sviluppare soluzioni di secondo livello. L'idea alla base è spostare la maggior parte delle transazioni "off-chain", ovvero al di fuori della blockchain principale, utilizzando quest'ultima non più come registro di ogni singola attività, ma come giudice finale e imparziale.

Il Lightning Network rappresenta la proposta più promettente e diffusa. Si tratta di una rete di canali di pagamento bidirezionali che permette agli utenti di scambiare fondi istantaneamente e con commissioni minime, aggiornando i saldi privatamente e trasmettendo alla blockchain solo le transazioni di apertura e chiusura del canale. Inoltre, attraverso l'uso di appositi contratti, il Lightning Network consente di instradare pagamenti attraverso nodi intermedi in modo sicuro e senza che questi possano sottrarre i fondi.

Malgrado ciò, come ogni sistema complesso, anche il Lightning Network presenta sfide architetturali. Se da un lato risolve il problema del throughput, dall'altro introduce nuove dinamiche legate alla liquidità, alla topologia della rete e a potenziali rischi di centralizzazione, dove pochi nodi potrebbero arrivare a gestire una porzione significativa del traffico.

\section*{Struttura della tesi}

La struttura dell'elaborato sarà quindi la seguente:
\begin{itemize}
    \item Il \textbf{Capitolo 1} analizza le limitazioni strutturali delle blockchain pubbliche e il trilemma della scalabilità, ponendo le basi per la necessità di soluzioni off-chain.
    \item Il \textbf{Capitolo 2} introduce le primitive crittografiche essenziali per i protocolli di secondo livello, come le funzioni di hash, le firme digitali e i timelocks.
    \item Il \textbf{Capitolo 3} esamina il ruolo di Bitcoin come livello base, focalizzandosi su come la blockchain garantisca la sicurezza dei fondi gestiti nei livelli superiori.
    \item Il \textbf{Capitolo 4} descrive nel dettaglio l'architettura dei canali di pagamento, spiegando i meccanismi di apertura, aggiornamento e chiusura, nonché le strategie per prevenire frodi tra le controparti.
    \item Il \textbf{Capitolo 5} estende l'analisi dal singolo canale all'intera rete Lightning, illustrando come avviene il routing dei pagamenti attraverso nodi intermedi preservando la privacy e la sicurezza.
    \item Infine, il \textbf{Capitolo 6} discute i limiti attuali della tecnologia, presentando un'analisi critica sulla centralizzazione della rete e sulle vulnerabilità sistemiche, delineando le possibili linee di ricerca futura.
\end{itemize}

%----------------------------------------------------------------------------------------
\chapter{Scalabilità delle blockchain e limiti strutturali}
%----------------------------------------------------------------------------------------
Le blockchain pubbliche, e Bitcoin in particolare, hanno dimostrato che è possibile ottenere consenso distribuito in un ambiente privo di fiducia reciproca. Esse hanno introdotto un grande cambio di paradigma nella gestione del valore digitale. Tuttavia, questa nuova soluzione architetturale comporta costi significativi in termini di efficienza.

In questo capitolo verranno analizzati i principi fondamentali che garantiscono la sicurezza di tali sistemi, ponendo l'attenzione a come gli stessi meccanismi di ridondanza e verifica diffusa, necessari per la decentralizzazione, ne limitino strutturalmente la scalabilità. Verrà presentato il cosiddetto "Trilemma della Scalabilità" e si osserverà come un'adozione globale dell'approccio on-chain renda necessaria l'introduzione di soluzioni di secondo livello, per colpa delle limitazioni fisiche di banda e della latenza.

\section{Evoluzione e principi fondamentali delle criptovalute}
Ad oggi, la maggior parte delle transazioni su Internet, e la totalità di esse prima del 2008, avviene tramite l'ausilio di terze entità fidate, quali banche o istituti finanziari, su cui ogni nodo della rete pone la propria fiducia. Sebbene questo modello sia ampiamente funzionante, presenta tutte le debolezze tipiche dei modelli \textbf{trust-based}. Le transazioni infatti non possono essere irreversibili perché gli istituti finanziari devono poter gestire eventuali dispute tra utenti, ma questo rende il denaro elettronico meno \textit{finale} rispetto a quello fisico e crea incertezza per i venditori. Gestire problemi, rimborsi e controlli antifrode genera dei costi aggiuntivi che ogni utente paga sotto forma di \textit{commissioni} rendendo i micropagamenti economicamente sconvenienti. Infine la presenza di un ente centrale rappresenta un \textbf{single point of failure}, ossia un punto critico la cui compromissione può compromettere l'intero sistema.~\cite{nakamoto2008bitcoin}

Lo scopo principale delle criptovalute è invece quello di operare in un ambiente decentralizzato, senza alcuna autorità centrale, basato sulla crittografia, nel quale due nodi della rete possono effettuare delle transazioni tra loro senza la necessità di fidarsi di un intermediario. Le transazioni sono computazionalmente impossibili da invertire e il sistema \textbf{blockchain} protegge dalle frodi sia venditori che i clienti. La validità di ogni operazione è garantita tramite calcoli matematici complessi e può essere verificata da chiunque in qualsiasi momento. La crittografia sostituisce quindi la fiducia verso gli intermediari con una prova matematica, non è necessario fidarsi di banche o istituti finanziari perché la correttezza di ogni operazione è verificabile pubblicamente.\cite{nakamoto2008bitcoin}

La \textbf{blockchain} è una combinazione di elementi crittografici di base come le \textbf{funzioni di hash}, le \textbf{firme digitali} e i protocolli di \textbf{consenso distribuito} (\textit{proof-of-work}), che interagiscono tra loro per creare un sistema sicuro di registrazione delle transazioni.\cite{nakamoto2008bitcoin}
Come evidenziato da Narayanan e Clark \cite{narayanan2017bitcoin}, l'innovazione di Nakamoto non risiede nell'invenzione di nuove primitive crittografiche, quanto nell'aver combinato in modo ingegnoso strumenti preesistenti, con un sistema di incentivi economici, creando il primo sistema realmente funzionante e autonomo.

Il cuore della blockchain su cui si basa Bitcoin è il \textbf{protocollo di gossip}, in cui tutte le modifiche che vengono apportate al registro delle transazioni vengono inviate in broadcast a tutti i nodi partecipanti alla rete. A causa di questo la blockchain di Bitcoin da sola non è in grado di gestire tutte le transazioni che avvengono quotidianamente nel mercato mondiale. Visa, uno dei principali circuiti di pagamento mondiali, utilizzato in oltre duecento paesi, è in grado di gestire picchi di 47000 transazioni al secondo, arrivando quindi ad una media di centinaia di milioni di transazioni al giorno\cite{alston2021constitutions}. Bitcoin, allo stato originale, è in grado di gestire solamente 7 transazioni al secondo, con blocchi di dimensione massima di 1 megabyte. Assumendo di poter avere i blocchi di dimensione infinita, e supponendo di utilizzare circa 300 bytes per ogni transazioni, per attuare la mole di lavoro gestita da Visa, Bitcoin genererebbe blocchi da 8 gigabytes ogni 10 minuti, arrivando quindi a 400 terabyte di dati all'anno.\cite{poon2016lightning}

Chiaramente nessun personal computer sarebbe in grado di gestire tale catena, né a livello di banda, né a livello di quantità di dati da elaborare. Se Bitcoin dovesse diventare il metodo più diffuso di pagamento online, la rete collasserebbe molto velocemente, oppure si creerebbe un fenomeno di estrema centralizzazione, in cui a gestire la rete sono solo i pochi nodi in grado di gestire quel volume di lavoro. Meno nodi gestiscono la rete e meno sarà accurato il registro delle transazioni, inoltre tali nodi potrebbero smettere di agire nell'interesse comune ed iniziare ad agire per il proprio interesse, aumentando i costi di transazione per poter operare scorrettamente. In casi estremi, i nodi non in grado di fare da miner, potrebbero affidare i loro fondi ai nodi più potenti, dandone loro la completa custodia.\cite{poon2016lightning}

Diventa quindi fondamentale che, nel caso in cui Bitcoin diventi estremamente popolare, ogni personal computer, con una normale capacità di calcolo, sia in grado di competere per validare i vari blocchi, risolvendo le criticità che rendono possibile la centralizzazione, e dando modo alle persone di fidarsi di tale sistema.

\section{Il trilemma della scalabilità nei sistemi decentralizzati}
Con l’aumentare delle transazioni, le blockchain pubbliche diventano lente e costose, smettendo di essere un sistema affidabile. La sfida che si sta affrontando è quella di migliorare questi meccanismi senza però dover sacrificare nessuno dei principi fondamentali delle blockchain.

Il \textbf{Trilemma della scalabilità} è un teorema coniato da Vitalik Buterin, cofondatore di Ethereum, che raggruppa i problemi principali a cui gli sviluppatori vanno incontro quando cercano di realizzare una nuova blockchain. Tali problemi sono tre e sono \textit{scalabilità}, \textit{decentralizzazione} e \textit{sicurezza}. Buterin afferma che queste tre siano le proprietà che una qualsiasi blockchain cerca di avere, e, affidandosi a tecniche semplici, sia possibile avere solo due di esse.\cite{buterin2021trilemma}

Tali proprietà sono così definite:
\begin{itemize}
    \item \textbf{Scalabilità:} la blockchain deve essere in grado di elaborare un numero di transazioni maggiore rispetto a quelle che può verificare da solo un normale nodo.
    \item \textbf{Decentralizzazione:} il sistema deve essere \textit{trustless}, non ci deve essere nessun nodo, o nessuno piccolo gruppo di nodi, in cui sia necessario porre la fiducia di ogni elemento della rete. Tale proprietà implica che il livello di fiducia tra i nodi debba essere ridotto al minimo.
    \item \textbf{Sicurezza:} la blockchain deve riuscire a resistere al maggior numero possibile di nodi, partecipanti alla rete, che cercano di attaccarla. Idealmente tale resistenza dovrebbe arrivare almeno al 50\% dei nodi, anche se una catena è considerata valida da sopra il 25\%.
\end{itemize}

La scalabilità è strettamente collegata con la decentralizzazione, ed è il principio cardine sul quale si basano le blockchain, nonostante sia molto complicato ottenerlo.

Mescolando le proprietà si ottengono tre diverse tipologie di sistemi, ognuno dei quali è costretto a sacrificare un principio, proprio come detto nel trilemma della scalabilità:
\begin{itemize}
    \item \textbf{Blockchain tradizionali:} si basano sul fatto che ogni partecipante alla rete sia un nodo a se stante in grado di validare ogni transazione. In questo modo si ottengono decentralizzazione e sicurezza, ma non la scalabilità. Di questa categoria fanno parte Bitcoin, Litecoin e altre catene simili.
    \item \textbf{Catene high-TPS:} si basano su un numero limitato di nodi, tipicamente tra 10 e 100, che mantengono il consenso tra di loro, gli altri nodi della rete devono fidarsi della maggior parte di questi nodi. Questa soluzione ottiene scalabilità e sicurezza, ma è chiaro che non sia decentralizzata.
    \item \textbf{Ecosistemi multi-chain:} si basa sul concetto di \textit{scalabilità orizzontale}, ossia la possibilità di avere più catene e di utilizzare un protocollo di comunicazione per farle comunicare tra loro. Questa soluzione risulta essere decentralizzata e scalabile, ma non sicura. Infatti ad un aggressore basterebbe ottenere la maggioranza dei nodi di consenso di una delle numerose catene per prenderne il controllo e generare problemi a valanga sulle altre.
\end{itemize} \cite{buterin2021trilemma}

La conclusione è che cercare di ottenere scalabilità a livello del protocollo di base, senza compromettere la decentralizzazione e la sicurezza, è incredibilmente difficile con l'architettura attuale. Bitcoin ha scelto di non scendere a compromessi sulla sicurezza e sulla decentralizzazione; di conseguenza, la scalabilità deve essere ricercata altrove.

\section{Off-chain e soluzioni di secondo livello}
Considerando le criticità evidenziate dal \textit{Trilemma della scalabilità} enunciato precedentemente, la comunità scientifica e gli sviluppatori di Bitcoin hanno spostato la loro attenzione verso soluzioni che non richiedono modifiche al protocollo di base, detto \textit{layer 1}. L'idea è quella di fare in modo che la maggior parte delle transazioni avvenga \textbf{off-chain}, ovvero al di fuori della blockchain principale, andando di fatto a costruire un livello superiore in grado di gestire tali transazioni, detto \textit{layer 2}.

Poon e Dryja \cite{poon2016lightning} introducono la possibilità di creare canali di pagamento tra due nodi partecipanti alla rete, che si scambiano denaro senza la necessità di registrare ogni transazione sulla blockchain. Se, per esempio, due nodi si scambiano denaro ogni giorno, e solo a loro interessa di queste transazioni ricorrenti, non è necessario che anche tutti gli altri nodi della catena siano sempre a conoscenza di ogni loro movimento. Così facendo si permette agli utenti di Bitcoin di attuare molteplici transazioni senza far collassare il sistema e senza rischiare di avere problemi di centralizzazione.

La soluzione consiste quindi nel creare questi canali, detti \textbf{canali di micropagamento}, che consentono di inviare grandi quantità di fondi in modo decentralizzato. In questo modo Bitcoin può scalare fino a miliardi di transazioni giornaliere utilizzando la potenza di calcolo di un normale laptop odierno.

I canali di micropagamento instaurano una relazione tra due parti, che aggiornano costantemente i propri saldi, evitando di passare sempre per la blockchain e registrando su di essa solo la transazione finale, figlia di tutte quelle precedenti avvenute off-chain. Questi canali non sono da intendere come reti separate da Bitcoin, ma rappresentano vere e proprie transazioni Bitcoin. Scegliere di inviare sulla blockchain principale un'unica transazione finale permette ad entrambe le parti di garantire il proprio saldo sulla rete.

Il funzionamento logico di base di questo meccanismo è il seguente:
\begin{enumerate}
    \item \textbf{Apertura:} Due nodi bloccano una somma di denaro comune in una transazione sulla blockchain. Questo è l'unico momento in cui la rete globale viene coinvolta inizialmente. Questa transazione di apertura viene chiamata \textit{Funding Transaction}.
    \item \textbf{Operatività Off-Chain:} Le parti possono scambiarsi un numero illimitato di transazioni aggiornando privatamente la ripartizione dei fondi bloccati. Queste operazioni sono istantanee e non richiedono commissioni di mining, poiché sono semplici scambi di dati firmati crittograficamente tra i due utenti.
    \item \textbf{Chiusura:} Quando le parti decidono di terminare la collaborazione, l'ultimo stato del bilancio viene inviato alla blockchain per la transazione finale. Non è necessario che entrambe i nodi richiedano di chiudere il canale, basta solo una delle due parti.
\end{enumerate}

In questo modello, la blockchain non agisce più come un registro contabile di ogni singola transazione, ma assume il ruolo di un giudice imparziale che interviene solo in caso di disputa o alla fine del rapporto economico tra le parti.

%----------------------------------------------------------------------------------------
\chapter{Primitive crittografiche per i protocolli off-chain}
%----------------------------------------------------------------------------------------
La sicurezza e il funzionamento dei protocolli di secondo livello non si basano sulla fiducia verso terze parti, ma sull'utilizzo combinato di specifiche primitive crittografiche. Mentre la blockchain di Bitcoin utilizza queste tecnologie per garantire il consenso globale, il Lightning Network le impiega per creare contratti intelligenti, detti \textit{Smart Contracts}, che permettono l'esecuzione sicura delle transazioni off-chain.

In questo capitolo verranno analizzati gli strumenti fondamentali necessari alla costruzione di un canale di pagamento: le \textit{funzioni di hash} per la creazione di vincoli condizionali, le \textit{firme digitali} per la gestione condivisa dei fondi e i \textit{vincoli temporali} per la gestione delle dispute.

\section{Funzioni di hash crittografico e loro proprietà}
Le funzioni di hash svolgono un ruolo fondamentale nella crittografia moderna e hanno numerose applicazioni nell'ambito della sicurezza informatica. Sono infatti utilizzate per esempio per:
\begin{itemize}
    \item Firme digitali
    \item Verifica dell'integrità dei file
    \item Sicurezza delle password
    \item Blockchain
    \item SSL/TLS protocolli
\end{itemize}
Una funzione di hash è una funzione \textbf{non invertibile} che trasforma una sequenza di bit di lunghezza arbitraria in una sequenza di bit di lunghezza predefinita, chiamata \textbf{digest}.

Le funzioni di hash specifiche per gli ambiti crittografici devono avere le seguenti proprietà:
\begin{itemize}
    \item \textbf{Determinismo} $\rightarrow$ lo stesso input inserito nella stessa funzione hash deve dare come risultato lo stesso output
    \item \textbf{Efficienza} $\rightarrow$ il valore hash deve venir calcolato rapidamente, indipendentemente dalla dimensione dell'input
    \item \textbf{Non invertibilità} $\rightarrow$ dato un digest non deve essere possibile risalire all'input che lo ha generato
    \item \textbf{Effetto valanga} $\rightarrow$ piccole modifiche nel messaggio di input determinano modifiche significative, apparentemente non correlate, nell'hash di output
\end{itemize} \cite{stallings2017cryptography}

Ognuna di queste caratteristiche è essenziale per rendere la funzione crittograficamente sicura. La problematica principale a cui queste funzioni devono essere in grado di resistere sono le \textbf{collisioni}. Avviene una collisione ogni volta che due input differenti generano lo stesso output. Di base, se un algoritmo genera delle collisioni significa che non è un algoritmo sicuro. \cite{stallings2017cryptography}

La famiglia di funzioni crittografiche di hash più utilizzata ad oggi è la \textbf{SHA}, \textit{Secure Hash Algorithm}, i vari algoritmi che ne fanno parte si distinguono per differenza di lunghezza del \textit{digest} e resistenza alle collisioni:
\begin{itemize}
    \item \textbf{SHA-1} $\rightarrow$ è stato l'algoritmo più usato della famiglia sha, diffuso in numerose applicazioni e protocolli nonostante ormai sia considerato insicuro, dato che la sua sicurezza è stata compromessa dai crittoanalisti. Produce un \textit{digest} di 160 bit, da un input lungo massimo $2^{64}-1$ bit.
    \item \textbf{SHA-2} $\rightarrow$ Nel 2001 vengono pubblicate dal NIST altre quattro funzioni di hash, ognuna con un \textit{digest} più lungo di quello originale. A far parte di questo sottogruppo sono \textbf{SHA-224}, \textbf{SHA-256}, \textbf{SHA-384} e \textbf{SHA-512}, che generano \textit{digest} rispettivamente di 224, 256, 384 e 512 bit. Gli algoritmi \textbf{SHA-256} e \textbf{SHA-512} lavorano rispettivamente con \textit{word} di 32 e 64 bit. La loro struttura è sostanzialmente identica anche se utilizzano un differente numero di rotazioni e di costanti addizionali. Gli altri due algoritmi, invece, sono semplicemente delle versioni troncate di questi, con hash calcolati con differenti valori iniziali. La sicurezza della famiglia SHA-2 è oggi considerata solida; tuttavia, la sua struttura è stata meno analizzata rispetto a SHA-1 prima della sua compromissione, motivo per cui il NIST ha promosso lo sviluppo di SHA-3.
    \item \textbf{SHA-3} $\rightarrow$ Nuovo membro della famiglia SHA trovato grazie ad un competizione lanciata dal NIST nel 2007, con l'obiettivo di sviluppare una nuova funzione di hashing per rafforzare le versioni precedenti.
\end{itemize} \cite{stallings2017cryptography}

L'algoritmo SHA-256 riveste un ruolo centrale nel protocollo Bitcoin: viene infatti utilizzato per calcolare l'hash di ciascun blocco, per collegare i blocchi della catena tra loro e, soprattutto, nel meccanismo di \textbf{Proof-of-Work}, dove i miner devono trovare un valore di nonce tale che l'hash del blocco risulti inferiore a una soglia prefissata, detta \textit{target}. 
Quindi è anche grazie a questo algoritmo se il sistema riesce a resistere alle modifiche retroattive e a garantire l'integrità della blockchain.

Nel contesto delle criptovalute, in particolare Bitcoin, ogni transazione e ogni blocco della blockchain vengono identificati da un hash calcolato applicando due volte la funzione di SHA-256, il processo si chiama \textbf{double hashing}. Questa doppia applicazione serve a ridurre la probabilità di collisioni e proteggere da eventuali attacchi. \cite{antonopoulos2017mastering}

Nel contesto specifico del Lightning Network, tuttavia, l'uso più rilevante delle funzioni di hash non è legato al mining o alla struttura a blocchi, ma alla creazione di vincoli condizionali per i pagamenti.

La proprietà di \textit{resistenza alla preimmagine} viene sfruttata per generare segreti crittografici fondamentali per il routing sicuro. Il meccanismo, che costituisce la base degli \textbf{Hashed Time-Lock Contracts (HTLC)}, funziona nel seguente modo:
\begin{enumerate}
    \item Il destinatario di un pagamento genera un numero casuale $R$, detto \textit{pre-image} o segreto.
    \item Viene calcolato l'hash di questo segreto: $H = \text{SHA-256}(R)$, denominato \textit{payment hash}.
    \item L'hash $H$ viene condiviso pubblicamente con il mittente e con la rete, mentre $R$ rimane segreto fino al momento dell'incasso.
\end{enumerate}

I fondi vengono vincolati a $H$ tramite uno smart contract: essi possono essere spesi solo da chi è in grado di rivelare la preimmagine $R$ che, passata attraverso la funzione SHA-256, restituisce l'hash $H$ specificato nel contratto. Data l'unidirezionalità della funzione, è computazionalmente impossibile per un attaccante risalire a $R$ conoscendo solo $H$, garantendo così che solo il legittimo destinatario possa sbloccare i fondi \cite{antonopoulos2017mastering}.

\section{Firme digitali e firme multiple}
\subsection{Firme digitali}
Le firme digitali vengono create per permettere ai sistemi di elaborazione di accertare l'identità di un utente. Il destinatario di un messaggio, o di una somma di denaro, deve poter essere in grado di verificare l'identità del mittente e l'integrità di ciò che ha ricevuto, dunque il metodo utilizzato deve rendere difficile ad un intruso di spacciarsi per qualcun altro o di modificare i messaggi inviati.

La firma digitale entra in gioco proprio nei sistemi \textit{trustless}, quando il mittente e il destinatario non si fidano l'uno dell'altro. Il meccanismo, per essere valido, deve rispettare i seguenti tre requisiti:
\begin{enumerate}
\item \textbf{Non ripudio}$\rightarrow$ non deve essere permesso ad un mittente di negare di aver mandato un messaggio da lui firmato
\item \textbf{Autenticazione e integrità}$\rightarrow$ il destinatario deve poter autenticare il messaggio, ossia accertare l'identità del mittente e l'integrità del messaggio ricevuto
\item \textbf{Irrefutabilità della ricezione}$\rightarrow$ il destinatario non deve poter sostenere di aver ricevuto un messaggio diverso da quello inviatogli dal mittente
\end{enumerate} \cite{stallings2017cryptography}

Il meccanismo crittografico adottato da Bitcoin si chiama \textbf{Elliptic Curve Digital Signature Algorithm}, ossia \textbf{ECDSA}. Con esso vengono firmate digitalmente le transazioni ed ogni nodo può dimostrare il possesso della propria chiave privata, senza però andare a rivelarla. Le chiavi private in Bitcoin sono molto importanti, perchè è con esse che si dimostra il possesso di una certa quantità di monete, se la chiave viene persa anche i fondi a lei associati saranno perduti, mentre se viene rubata consente di spendere il denaro dell'utente.

ECDSA si basa sulla crittografia a \textbf{curve ellittiche}, una variante della crittografia asimmetrica che riesce ad ottenere lo stesso livello di sicurezza di algoritmi come RSA utilizzando chiavi molto più piccole, risultando quindi più efficiente. \cite{antonopoulos2017mastering}

La \textbf{chiave privata} di ogni utente viene scelta randomicamente in un intervallo definito, e la \textbf{chiave pubblica} viene derivata tramite un'operazione matematica detta \textbf{moltiplicazione scalare} su una curva ellittica. La curva adottata da Bitcoin è la \textbf{secp256k1}, che opera su un campo finito di 256 bit, scelta per la sua semplicità ed efficienza. \cite{sec2_2010}

La sicurezza del sistema si basa sulla difficoltà computazionale di risalire alla chiave privata di determinato utente conoscendo solo quella pubblica, ossia risolvere il \textbf{problema del logaritmo discreto su curve ellittiche}.

Durante una firma, l'algoritmo genera una coppia di valori partendo dal messaggio e dalla chiave privata del nodo in questione, questi due numeri costituiscono quindi la firma digitale. Chiunque può verificarne la veridicità utilizzando la chiave pubblica del mittente.

ECDSA garantisce l'autenticità e la non ripudiabilità delle transazioni, rendendo possibile un sistema di scambio decentralizzato.
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth, keepaspectratio]{figures/ecdsa.png} 
    \caption[Schema ECDSA]{Schema logico della firma digitale ECDSA. La chiave privata firma l'hash del messaggio; la chiave pubblica permette la verifica senza rivelare il segreto. (Fonte: rielaborazione da Scrypt Platform)}
    \label{fig:ECDSA}
\end{figure}

\subsection{Firme multiple}
Per implementare un sistema complesso come il Lightning Network richiede meccanismi avanzati e di conseguenza le firme singole non bastano più. Per gestire la proprietà condivisa dei canali sono richieste le \textbf{firme multiple}, o \textbf{multisig}, che permettono di vincolare i fondi ad un gruppo di persone.

In questa tipologia di schemi viene impostata una condizione per cui nello script di output vengono registrate $k$ chiavi pubbliche ed almeno $t$ di queste devono fornire una firma valida per spendere i fondi. Schemi come questo vengono definiti come $t$-of-$k$. Per esempio in una firma multipla 2-of-3 ci sono tre potenziali chiavi pubbliche, ed almeno due di queste devono essere usate per creare una firma valida per spendere i fondi. \cite{antonopoulos2017mastering}

Nel contesto del Lightning Network, viene utilizzato uno schema 2-of-2. Quando due utenti aprono un canale di pagamento, creano una transazione di finanziamento, la \textit{Funding Transaction}, verso un indirizzo multisig controllato congiuntamente. Dal momento in cui il canale è stato creato, la regola imposta dalla blockchain è semplice e stretta: per muovere quei fondi è necessario il consenso di entrambe le parti, questo si traduce nella necessità che entrambe le parti firmino le modifiche allo stato dei fondi.

Questa architettura agisce come una garanzia di sicurezza preventiva:
\begin{itemize}
    \item Nessuna delle parti può sottrarre i fondi all'altra, poiché mancherebbe la seconda firma necessaria.
    \item In caso di disaccordo, i fondi rimangono bloccati.
\end{itemize}
In realtà, per quanto riguarda questo ultimo punto, nel protocollo sono previsti meccanismi di uscita che permettono di risolvere la disputa, come i \textit{timelock}, che verranno descritti successivamente. \cite{poon2016lightning}

In sintesi, il Multisig rende i fondi vincolati in un canale condivisi, costringendo le parti a cooperare per aggiornare lo stato del canale.

\section{Vincoli temporali nelle transazioni}
Nei sistemi di pagamento tradizionali l'obiettivo è rendere il denaro derivante da una transazione immediatamente spendibile; nei sistemi complessi come il Lightning Network, invece, è necessario che i fondi derivati da una transazione non siano spendibili immediatamente, questo per evitare truffe e frodi.

Verrà chiarito in seguito come il non permettere di spendere subito i fondi derivanti da una transazioni sia una misura di sicurezza che permette alla controparte del canale di realizzare di aver subito una truffa e di agire di conseguenza.

Diventa quindi necessario gestire il tempo all'interno delle transazioni. Quest'ultimo nella blockchain di Bitcoin non è misurato prevalentemente in secondi, ma in \textbf{altezza di blocco}, \textit{Block Height}, sebbene sia possibile utilizzare anche il timestamp Unix. Poiché un blocco viene minato in media ogni 10 minuti, definire un intervallo di 144 blocchi equivale a circa 24 ore.

Entrano quindi in gioco i \textbf{timelock}. Ne esistono due tipi:
\begin{itemize}
    \item \textbf{Timelock assoluti:} rendono l'output di una transazione spendibile solo dopo un determinato punto nel futuro, ad esempio dopo il blocco 850.000.
    A livello di script, questi sono implementati tramite l'opcode \textbf{\texttt{OP\_CHECKLOCKTIMEVERIFY}} (CLTV), introdotto con il BIP 65 \cite{bip65}.
    Questi vengono utilizzati per i \textbf{rimborsi}. Come detto precedentemente, quando due nodi aprono un canale bloccano dei fondi con la \textit{Funding Transaction}, questa rende tali fondi comuni ed impone la necessità della firma di entrambe le parti per fare un qualsiasi movimento. Se un nodo, una volta creato il canale, smette di rispondere, o va offline perennemente, l'altro, dopo un determinato periodo, può recuperare i fondi che aveva bloccato grazie a una transazione che diviene valida solo allo scadere del timelock. \cite{antonopoulos2017mastering}
    \item \textbf{Timelock relativi:} introdotti con il BIP 112 \cite{bip112} tramite l'opcode \textbf{\texttt{OP\_CHECKSEQUENCEVERIFY}} (CSV), essi non guardano una data fissa nel calendario, ma l'età dell'output che si sta spendendo. Questo tipo di timelock impone la seguente condizione: una transazione $X$ che spende un output $Y$ è valida se e solo se sono passati $n$ blocchi dalla conferma di $Y$ sulla blockchain.
    Vengono utilizzati nel caso di \textbf{dispute}, e sono l'elemento centrale del meccanismo di sicurezza del Lightning Network. Tenendo bloccati i fondi per un certo numero di blocchi, un'eventuale vittima può accorgersi di essere stata truffata e creare una finestra di contestazione. La vittima ha tempo a sufficienza per accorgersi del tentativo di frode e, utilizzando una chiave di revoca, prelevare l'intera somma prima che il timelock scada e il truffatore possa incassare. \cite{antonopoulos2017mastering}
\end{itemize}

%----------------------------------------------------------------------------------------
\chapter{Bitcoin come livello base di sicurezza}
%----------------------------------------------------------------------------------------
Nel capitolo precedente sono state analizzate le primitive crittografiche necessarie per la costruzione di contratti condizionali e canali di pagamento. Tuttavia, per ottenere un sistema funzionante, sicuro e soprattutto \textit{trustless}, gli elementi appena trattati, da soli, non bastano. Sorge quindi la necessità di un'infrastruttura sottostante, in grado di interpretarli ed eseguirli in modo inappellabile.

Il protocollo originale di Bitcoin, a questo punto, non è più utilizzato solo come valuta digitale, ma assume un ruolo cruciale, diventando un arbitro imparziale per le \textit{dispute}.
Come teorizzato nel whitepaper di Satoshi Nakamoto \cite{nakamoto2008bitcoin}, la blockchain risolve il problema della doppia spesa attraverso una catena di prove crittografiche basate sul lavoro computazionale. Per le soluzioni di secondo livello come il Lightning Network, questa proprietà di immutabilità è fondamentale: la blockchain principale diventa l'ente a cui le parti si rivolgono solo in caso di controversia o per finalizzare gli scambi avvenuti privatamente.

Come detto nei capitoli precedenti, è importante sottolineare che le transazioni eseguite nel Lightning Network non sono alternative a Bitcoin, ma sono vere e proprie transazioni Bitcoin valide, la differenza è che queste vengono trattenute dai nodi e non sono trasmesse immediatamente alla rete globale. La sicurezza di questi scambi \textit{off-chain} deriva interamente dalla certezza che, in qualsiasi momento, lo stato corrente del canale possa essere pubblicato e confermato sulla blockchain principale.

Questo capitolo analizzerà le componenti strutturali di Bitcoin che rendono possibile tale architettura. In primo luogo, verrà esaminata la struttura delle transazioni, successivamente, si discuterà il ruolo della Proof-of-Work non solo come meccanismo di consenso, ma come orologio universale per la gestione dei vincoli temporali. Infine, verrà trattata l'evoluzione del protocollo con l'introduzione di Segregated Witness (SegWit), un aggiornamento critico che, risolvendo la vulnerabilità della \textit{transaction malleability}, ha reso possibile l'implementazione sicura ed efficiente dei canali di pagamento moderni.

\section{Struttura delle transazioni}
Le \textbf{transazioni} permettono ai nodi di scambiarsi i Bitcoin \cite{conoscenti2019payment}, la possibilità di attuare tali operazioni è un aspetto fondamentale per una moneta elettronica. Senza transazioni i vari proprietari di monete non potrebbero scambiarsele tra loro e si andrebbe dunque a perdere il concetto di moneta stessa.

Ogni utente possessore di bitcoin può trasferire una certa quantità di valuta ad un altro utente andando ad apporre la propria firma digitale sull'hash della transazione precedente e la chiave pubblica del nuovo proprietario.

Sorge però un problema: un qualsiasi utente non può verificare che un possessore di bitcoin che ha appena effettuato una transazione non abbia già speso quelle monete altre volte, ossia non abbia effettuato un \textbf{double-spending}. Di fatto il denaro digitale può essere duplicato senza alcuna fatica, proprio come qualsiasi altro oggetto digitale.\cite{conoscenti2019payment}

Bisogna quindi trovare un modo per dimostrare ai beneficiari di una transazione che le monete che stanno ricevendo non sono già state spese. Il sistema di moneta digitale introdotto da David Chaum nel 1983, noto come eCash \cite{chaum1983blind}, è il primo a risolvere il problema della doppia spesa, ma in un ambiente centralizzato, di conseguenza Bitcoin è il primo metodo di pagamento digitale in grado di risolvere questo problema in maniera totalmente decentralizzata.

Per fare ciò tutti i nodi della rete devono essere a conoscenza di tutte le transazioni che sono state eseguite fino a quel momento e devono essere tutti d'accordo sull'ordine cronologico in cui sono avvenute, dunque tutte le transazioni devono essere pubbliche.

Per accordare ogni nodo sull'ordine cronologico si utilizza un \textbf{timestamp server} che prende in input un insieme di dati e ne calcola l'hash per poi pubblicarlo. Rendendo l'hash pubblico chiunque può verificare che quei dati dovevano già esistere al momento della pubblicazione. Ogni nuovo timestamp include anche l'hash del precedente in modo tale da creare una blockchain.

In sintesi il timestamp server è usato per creare una prova temporale immutabile dell'esistenza dei dati.~\cite{nakamoto2008bitcoin}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/transazioni.png}
    \caption{Struttura di una transazione Bitcoin composta da input e output. Ogni input fa riferimento a un output non speso di una transazione precedente. Fonte: Nakamoto\cite{nakamoto2008bitcoin}.}
    \label{fig:tx_structure}
\end{figure}


\subsection{I satoshi}
I \textbf{satoshi} sono l'unità più piccola utilizzabile nel protocollo originale di Bitcoin \cite{antonopoulos2017mastering}. La relazione che intercorre tra bitcoin e satoshi è la seguente:
\begin{equation}
1 \text{ sat} = 10^{-8} \text{ BTC} = 0,00000001 \text{ BTC}
\end{equation}
L'evoluzione verso soluzioni di secondo livello, come il Lighting Network, ha reso necessaria una granularità ancora maggiore, introducento così i \textbf{millisatoshi}, o \textbf{msat}. questa suddivisione è fondamentale per permettere il calcolo di commissioni di routing estremamente basse \cite{bolt1_protocol}. I \textit{msat} seguono la relazione sottostante:
\begin{equation}
1 \text{ msat} = 10^{-3} \text{ sat} = 10^{-11} \text{ BTC}
\end{equation}

\subsection{Il modello UTXO}
A differenza dei sistemi bancari tradizionali o di altre tipologie di monete virtuali, Bitcoin non utilizza un modello basato sui conti o sul portafoglio. Il software dà l'impressione che le monete vengano spostate da un portafoglio ad un altro, quando in realtà queste si muovono di transazione in transazione. Ognuna di esse spende i \textbf{satoshi} ricevuti, che sono gli output di una o più transazioni passate. L'output si ogni transazioni può essere suddiviso in più parti, per permettere di spedire i fondi a nodi differenti, ma ognuna di queste parti è e deve essere spendibile una sola volta \cite{antonopoulos2017mastering}.

Nello specifico, ogni output è univocamente identificato tramite il \textbf{Transaction Identifier} (TXID), ovvero l'hash della transazione firmata da cui ha origine. Poiché ogni singolo output può essere speso una sola volta, l'insieme di tutti gli output registrati sulla blockchain può essere categorizzato in due insiemi disgiunti: gli output già spesi e gli output non ancora spesi, definiti \textbf{Unspent Transaction Outputs (UTXO)}. Una transazione risulta valida se e solo se essa utilizza esclusivamente UTXO esistenti come propri input.

Eccezion fatta per le transazioni di \textit{coinbase}, ovvero le transazioni create dei miner per introdurre nuova moneta del sistema, il protocollo impone un rigoroso bilancio:
se il valore totale degli output di una transazione eccede quello dei suoi input, la transazione viene considerata invalida e rigettata dalla rete. Al contrario, qualora il valore degli input sia superiore a quello degli output, la differenza viene interpretata come commissione di transazione, detta \textit{transaction fee}, e può essere riscossa dal miner che include la transazione all'interno di un blocco.

Questo modello presenta proprietà fondamentali per i protocolli di secondo livello. In particolare:
\begin{itemize}
    \item Ogni stato di un canale di pagamento può essere rappresentato come una possibile spesa futura degli UTXO bloccati nella transazione di funding.
    \item La spesa concorrente di uno stesso UTXO è impossibile per costruzione, eliminando alla radice il problema del double-spending.
    \item Gli UTXO permettono di vincolare fondi tramite script arbitrari, consentendo la realizzazione di contratti condizionali.
\end{itemize}

Come osservato da Poon e Dryja \cite{poon2016lightning}, la possibilità di bloccare e successivamente ridistribuire UTXO condivisi è il meccanismo alla base dei canali di pagamento.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{figures/propTransaction.png}
    \caption{Propagazione e validazione di una transazione nella rete Bitcoin. Ogni nodo verifica la correttezza della transazione prima di propagarla ulteriormente. Fonte: Bitcoin Developer Documentation \cite{bitcoin_dev_blockchain}.}
    \label{fig:tx_propagation}
\end{figure}

\subsection{Transazioni e script di spesa}
In Bitcoin è importante distinguere tra la struttura di una transazione e le condizioni che ne regolano la spendibilità. Una transazione definisce quali UTXO vengono consumati e quali nuovi output vengono creati, ma non contiene logica esecutiva complessa. Le regole che determinano chi e quando può spendere un output sono invece espresse tramite \textbf{Bitcoin Script}, un linguaggio di scripting basato su uno stack, abbastanza limitato. \cite{antonopoulos2017mastering}.

Questa scelta progettuale riduce la superficie di attacco del protocollo e garantisce che il comportamento delle transazioni sia deterministico e facilmente verificabile dai nodi della rete. Ogni output contiene uno script di blocco, lo \textit{scriptPubKey}, mentre per spendere tale output è necessario fornire uno script di sblocco, \textit{scriptSig}, che soddisfi le condizioni imposte.

Nel Lightning Network, Bitcoin Script viene utilizzato per costruire contratti condizionali che combinano firme multiple, vincoli temporali e segreti crittografici. Sebbene il linguaggio non permetta smart contract complessi, la sua semplicità consente di implementare canali di pagamento sicuri senza compromettere la decentralizzazione del layer base \cite{poon2016lightning}.


\section{Struttura dei blocchi}
Ogni blocco della blockchain di Bitcoin è costituito da due sezioni:
\begin{itemize}
    \item \textbf{Block header} $\rightarrow$ l'intestazione del blocco.
    \item \textbf{Block body} $\rightarrow$ l'elenco delle transazioni appartenenti al blocco.
\end{itemize}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/blockBitcoin.png}
    \caption{Struttura di un blocco Bitcoin. Le transazioni sono organizzate in un Merkle tree, il cui hash radice è incluso nell’header del blocco. Fonte: Provino, rielaborazione da \cite{provino_merkle}.}
    \label{fig:block_structure}
\end{figure}

Le informazioni contenute nell'intestazione sono necessarie a collegare i vari blocchi tra loro e a verificarne la validità. Nella figura \ref{fig:block_structure} possiamo vedere quali sono gli elementi che compongono l'header di un tipico blocco della blockchain di Bitcoin:
\begin{itemize}
    \item \textbf{Version} $\rightarrow$ 4 bytes, indica la versione corrente del blocco e dunque le regole di validazione che esso sta seguendo.
    \item \textbf{PrevHashBlock}$\rightarrow$ 32 bytes, rappresenta il doppio hash del header del blocco precedente, necessario per rendere tale struttura una catena. Garantisce che nessun blocco precedente possa essere modificato senza modificare anche l'intestazione di questo. Ovviamente l'unico blocco che non ha un predecessore è il primo, che viene chiamato \textbf{genesis block}.
    \item \textbf{MerkleRootHash} $\rightarrow$ 32 bytes, è il doppio hash della root dell'albero di Merkle composto da tutte le transazioni appartenenti al blocco in questione. Modificare una transazione significa anche modificare questo elemento del blocco.
    \item \textbf{Timestamp} $\rightarrow$ 4 bytes, timestamp approssimato della creazione del blocco. Deve essere maggiore del timestamp medio degli 11 blocchi precedenti.
    \item \textbf{Bits/Target} $\rightarrow$ 4 bytes, codifica compatta della difficoltà richiesta per trovare un hash valido per risolvere il blocco.
    \item \textbf{Nonce} $\rightarrow$ 4 bytes, numero arbitrario trovato dai miners che rende l'hash del blocco valido, ossia inferiore al target. Se tutti i valori a 32 bit vengono tentati si può aggiornate il timestamp o la Merkle root.
\end{itemize}

I Merkle tree permettono di rappresentare in modo compatto l’insieme delle transazioni incluse in un blocco. Attraverso una struttura ad albero basata su funzioni hash, è possibile verificare l’appartenenza di una singola transazione al blocco senza dover scaricare l’intero contenuto, proprietà fondamentale per i nodi leggeri. \cite{provino_merkle}

Per quanto riguarda invece il body del blocco si nota che il primo elemento all'interno dell'elenco delle transazioni e la cosiddetta \textbf{coinbase transaction}, ossia i nuovi bitcoin che sono stati generati e dati come ricompensa al miner che ha risolta il blocco in questione. Questo meccanismo, noto come \textbf{block reward}, rappresenta l'unico modo con cui vengono emessi nuovi bitcoin nel sistema. ~\cite{bitcoin_dev_blockchain}

La struttura dei blocchi e la loro concatenazione tramite Proof-of-Work forniscono una nozione condivisa di tempo e finalità, che viene sfruttata direttamente dai protocolli di secondo livello per gestire vincoli temporali e risolvere eventuali dispute.

\section{Proof-of-Work: meccanismo di consenso e arbitraggio}
Nel protocollo originiale di Nakamoto \cite{nakamoto2008bitcoin}, la \textbf{Proof of Work} è il meccanismo adottato per garantire la sicurezza dalla rete, impedire il \textit{double spending} e confermare le transazioni attraverso un processo di competizione tra i miner che richiede un enorme potenza di calcolo e di energia. La funzione principale della PoW è quindi quella di rendere estremamente costoso e impraticabile per un malintenzionato manomettere la rete.

Per il lighting network questo meccanismo è fondamentale perché garantisce sicurezza e veridicità sulla blockchain, e la rende immutabile. Inoltre tale sistema viene anche utilizzato come orologio centrale, dato che esso genera un blocco ogni dieci minuti. \cite{antonopoulos2022masteringLN}

È necessario prima definire la figura dei \textbf{miner}: sono computer, tipicamente calcolatori dotati di molta potenza, che convalidano le transazioni risolvendo i vari blocchi ed aggiungendoli alla blockchain. Per fare ciò, competono per risolvere problemi crittografici complessi, colui che risolve il problema per primo viene ricompensato con nuove unità di Bitcoin.

La \textbf{Proof of Work} consiste nel trovare un valore di \textit{Nonce} che permetta all'hash del blocco di iniziare con un numero predefinito di zeri. Tale numero viene rappresentato dal valore \textit{Target} nell'header di ogni blocco. La quantità di lavoro richiesta per risolvere il problema è esponenziale rispetto al numero di zeri richiesti, ma, una volta trovata la soluzione, ogni nodo della rete può verificare con facilità la validità del blocco. \cite{nakamoto2008bitcoin}

Ogni miner deve dunque risolvere il seguente problema:
\[
H = \text{SHA256}\big(\text{SHA256}(\text{BlockHeader}(N))\big)
\]
\[
\text{Trovare } N \text{ (nonce) tale che } H < T \text{ (target)}       \cite{mining_tech_paper}
\]

Come detto nei capitoli precedenti una delle caratteristiche che rende così gettonate le funzioni di hash è l'impossibilità di risalire all'input conoscendo il risultato. È proprio questa la proprietà su cui si basa la Proof of Work, infatti, quello di trovare un double hash per il blocco che contenga un determinato numero di zeri iniziali è un problema che può essere risolto solo a tentativi. Nessun miner è in grado di costruire artificialmente un \textit{nonce} in grado di risolvere il blocco. Una volta che la soluzione è stata provata però tutti i nodi sono in grado di calcolare l'hash del blocco e verificare che esso rispetti il numero di zeri richiesto. Questo perchè le funzioni hash devono essere \textit{efficienti}. \cite{hash_intro_paper}

La \textbf{PoW} risolve anche un altro problema fondamentale: quello di determinare in modo affidabile la rappresentanza nella decisione di maggioranza. La fiducia nella \textbf{blockchain} si basa sul \textbf{consenso distribuito}, infatti un nuovo blocco può essere aggiunto alla catena solo quando la maggioranza dei partecipanti della rete concorda sulla sua validità. Se per rappresentare la maggioranza venisse utilizzato un meccanismo \textit{one-IPaddress-one-vote} il sistema sarebbe nella mani di chi è in grado di allocare in maggior numero di indirizzi IP. Invece la PoW si basa su un meccanismo \textbf{\textit{one-CPU-one-vote}}, quindi la catena considerata valida è la catena più lunga, ovvero quella che incorpora la maggior quantità di lavoro computazionale. Se la maggioranza della potenza delle CPU è rappresentata da nodi onesti vuol dire che la loro catena crescerà più velocemente rispetto a catene fasulle generate da nodi non onesti. Per modificare un blocco passato della catena corrente un malintenzionato dovrebbe ricalcolare la PoW di tutti i blocchi successivi e riuscire anche a superare la crescita della blockchain originale. \cite{nakamoto2008bitcoin}

Per compensare all'aumento di velocità e potenza hardware e le variazioni nel numero di nodi attivi nel tempo, la \textbf{difficoltà} della proof-of-work viene regolata tramite una \textbf{media mobile} che mantiene costante il numero medio di blocchi generati per ora. Se i nuovi blocchi vengono prodotti troppo rapidamente, la difficoltà verrà aumentata. Essa rappresenta il \textit{numero di zeri iniziali richiesti nel doppio hash} e questo valore è memorizzato nel campo \textbf{nBits/Target}.

Ogni nodo conosce la difficoltà corrente leggendone il valore dall'header dell'ultimo blocco valido della blockchain. Tipicamente la difficoltà viene aggiornata ogni 2016 blocchi, per mantenere una media costante di un blocco ogni 10 minuti. \cite{mining_tech_paper}

Per comprendere al meglio il meccanismo verrà approfondito il campo \textbf{nBits/Target} presente nell'header di ciascun blocco. Come già detto esso rappresenta una \textit{codifica compatta} del valore di \textbf{target}, ovvero la soglia numerica a cui l'hash doppio SHA-256 del blocco deve risultare inferiore o uguale per essere considerato valido.  
Il valore \texttt{nBits} è composto da:
\begin{itemize}
  \item una \textbf{mantissa} ($m$), che occupa i 3 byte meno significativi,
  \item un \textbf{esponente} ($e$), rappresentato dal byte più significativo.
\end{itemize}
Il target effettivo si ottiene espandendo tale valore compatto secondo la formula:
\[
\text{target} = m \times 2^{8(e - 3)}.
\]

Più piccolo è il valore del target, maggiore sarà la difficoltà richiesta per trovare un hash valido.  
Infatti, poiché la funzione di hash SHA-256 produce risultati uniformemente distribuiti nello spazio $[0, 2^{256}-1]$, la probabilità che un singolo hash risulti inferiore al target è:
\[
P(\text{hash valido}) = \frac{\text{target}}{2^{256}}.
\]

La difficoltà viene quindi definita come il rapporto tra il target del \textit{genesis block} e il target corrente:
\[
\text{difficulty} = \frac{\text{target}_{\text{genesis}}}{\text{target}_{\text{current}}}.
\]
Per convenzione, al blocco di genesi viene assegnata difficoltà 1.  
Questo significa che il suo valore di target rappresenta il livello di difficoltà base, rispetto al quale vengono calcolate tutte le difficoltà successive. \cite{mining_tech_paper}

Per comprendere al meglio queste formule posso essere applicate partendo dal \textit{genesis block} sapendo che il suo valore \texttt{nBits} è \texttt{0x1d00ffff}, da cui ricaviamo:
\[
m = 0x00ffff = 65535 \quad e = 0x1d = 29
\]
e quindi:
\[
\text{target}_{\text{genesis}} = 65535 \times 2^{8(29 - 3)} = 65535 \times 2^{208} \approx 1.73 \times 10^{67}.
\]
La probabilità che un hash casuale risulti valido è pertanto:
\[
P = \frac{\text{target}_{\text{genesis}}}{2^{256}} \approx 2.33 \times 10^{-10},
\]
equivalente a circa $4.3 \times 10^{9}$ tentativi medi, ovvero circa 4 miliardi di hash per trovare un nonce corretto.

Se la difficoltà aumenta, proporzionalmente il target diminuisce.  
Ad esempio, con una difficoltà pari a 100, il target sarà cento volte più piccolo:
\[
\text{target}_{100} = \frac{\text{target}_{\text{genesis}}}{100},
\]
e la probabilità di successo per singolo hash diventa:
\[
P_{100} = \frac{\text{target}_{100}}{2^{256}} = \frac{1}{100} \times P_{\text{genesis}}.
\]

All’aumentare della difficoltà, il numero medio di zeri iniziali nell’hash valido cresce, questo perché un target più basso richiede che l’hash si trovi in una porzione sempre più piccola dello spazio di output di SHA-256 \cite{mining_tech_paper}.

La \textbf{Proof-of-Work} è un meccanismo di sicurezza robusto ma poco efficiente, che ha garantito la sopravvivenza e l'integrità di Bitcoin a scapito della sua sostenibilità \cite{poon2016lightning}. Di seguito verranno trattate le principali problematiche:

\paragraph{Consumo energetico}
Il limite principale della Proof-of-Work è l'elevato consumo energetico. Il mining richiede una potenza di calcolo sempre maggiore per mantenere il tempo medio di generazione dei blocchi, comportando enormi sprechi di energia elettrica. Col tempo questo ha sollevato preoccupazioni ambientali e portato alla ricerca di modelli e strutture alternative. Di fatti l'\textbf{hash rate} di Bitcoin è dell'ordine di 1020 hash al secondo e, considerando tutti i miner, il consumo energetico totale per l'elaborazioni è vicino a quello di un paese con oltre \textit{45 milioni} di abitanti\cite{tse2022_lecture15_pos} . Sebbene una percentuale significativa di tale energia provenga da fonti rinnovabili, si tratta comunque di una grossa spesa. \cite{kufeoglu2019_energy_consumption_bitcoin}

\paragraph{Scalabilità limitata}
I blocchi possono contenere solo una ridotta quantità di transazioni ciascuno e il tempo medio di generazione di un singolo blocco è di circa \textit{10 minuti}. Questo rappresenta un vincolo importante che impedisce a Bitcoin di competere o sostituire i tradizionali metodi di pagamento\cite{tse2022_lecture15_pos} .

Queste limitazioni, insite nel \textit{Layer 1}, non rappresentano un fallimento del protocollo, ma una scelta progettuale per massimizzare la sicurezza. Tuttavia, esse rendono indispensabile lo spostamento della logica dei micropagamenti verso soluzioni di secondo livello, come il \textbf{Lightning Network}, oggetto dei capitoli successivi.


\section{Transaction malleability e introduzione di SegWit}
\section{Bitcoin come livello base per il Lightning Network}

%----------------------------------------------------------------------------------------
\chapter{Architettura e funzionamento dei canali di pagamento}
%----------------------------------------------------------------------------------------
I canali di pagamento permettono a due utenti di scambiarsi fondi più volte senza registrare ogni operazione sulla blockchain.

\section{Apertura, gestione e chiusura di un canale}
\section{Aggiornamento dello stato e meccanismi di sicurezza}
\section{Gestione dei nodi offline e ruolo delle watchtower}

%----------------------------------------------------------------------------------------
\chapter{Dal singolo canale di pagamento alla rete Lightning}
%----------------------------------------------------------------------------------------
Collegando più canali tra loro è possibile costruire una rete di pagamenti globale.

\section{Pagamenti attraverso nodi intermedi}
\section{Routing dei pagamenti e diffusione delle informazioni}
\section{Aspetti di privacy nel Lightning Network}

%----------------------------------------------------------------------------------------
\chapter{Limiti del Lightning Network e sviluppi futuri}
%----------------------------------------------------------------------------------------
Nonostante i vantaggi, il Lightning Network presenta ancora diversi limiti e criticità.

\section{Topologia della rete e problemi di centralizzazione}
\section{Vulnerabilità e attacchi}
\section{Proposte di miglioramento e linee di ricerca}

%----------------------------------------------------------------------------------------
\chapter*{Conclusioni}
\addcontentsline{toc}{chapter}{Conclusioni}
%----------------------------------------------------------------------------------------
In questa tesi è stato analizzato il Lightning Network come possibile soluzione al problema della scalabilità...

%----------------------------------------------------------------------------------------
% BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\backmatter
\bibliographystyle{alpha}
\bibliography{bibliography}

\end{document}