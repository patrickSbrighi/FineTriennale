\documentclass[12pt,a4paper,openright,twoside]{book}
\usepackage[utf8]{inputenc}
\usepackage[italian]{babel} % Aggiunto per la sillabazione italiana
\usepackage{disi-thesis}
\usepackage{code-lstlistings}
\usepackage{notes}
\usepackage{shortcuts}
\usepackage{acronym}
\usepackage{caption}

\school{\unibo}
\programme{Corso di Laurea in Ingegneria e Scienze Informatiche}
\title{Oltre la Blockchain: Pagamenti Off-Chain e Lightning Network tra Scalabilità e Sicurezza}
\author{Patrick Sbrighi}
\date{\today}
\subject{Crittografia}
\supervisor{Prof. Luciano Margara}
\session{III}
\academicyear{2024-2025}

% Definizione Acronimi
\acrodef{HTLC}{Hashed Time-Lock Contract}
\acrodef{PoW}{Proof-of-Work}
\acrodef{LN}{Lightning Network}

\mainlinespacing{1.241}

\begin{document}

\frontmatter\frontispiece

\begin{abstract}	
Questa tesi analizza il Lightning Network come soluzione al problema della scalabilità delle blockchain pubbliche, con particolare attenzione agli aspetti architetturali e di sicurezza. L’obiettivo è fornire una panoramica chiara dei meccanismi principali, evidenziandone vantaggi, limiti e possibili sviluppi futuri.
\end{abstract}

%----------------------------------------------------------------------------------------
\tableofcontents   
%----------------------------------------------------------------------------------------

\mainmatter

%----------------------------------------------------------------------------------------
\chapter*{Introduzione}
\addcontentsline{toc}{chapter}{Introduzione}
%----------------------------------------------------------------------------------------
Con la pubblicazione del whitepaper su Bitcoin da parte di Satoshi Nakamoto\cite{nakamoto2008bitcoin}, viene per la prima volta presentata la blockchain, una tecnologia innovativa che ha ridefinito le fondamenta dei sistemi distribuiti. Sfruttando tale innovazione viene mostrata la possibilità di trasferire valore su scala globale senza la necessità di intermediari fiduciari o autorità centrali. Questa architettura non rappresenta solamente un avanzamento a livello informatico, ma simboleggia anche un cambiamento sociale ed economico, infatti, per la prima volta, la fiducia viene spostata dalle istituzioni agli algoritmi crittografici, permettendo alle parti di cooperare direttamente senza la necessità di conoscersi e fidarsi reciprocamente.

Tuttavia, questo sistema si basa su un registro distribuito mantenuto da una rete peer-to-peer, dove il consenso sullo stato dei fondi viene raggiunto attraverso un protocollo di gossip che diffonde in broadcast ogni transazione a tutti i partecipanti della rete. Tale approccio, sebbene garantisca sicurezza e decentralizzazione, impone pesanti limiti per quanto riguarda la capacità del sistema di gestire elevate quantità di transazioni.

Nello schema originale di Bitcoin ciascun nodo deve validare e memorizzare ogni transazione che avviene a livello globale, il problema principale, infatti, risiede proprio in questo. Se si verificasse un aumento smisurato del numero di transazioni il sistema crollerebbe, mentre se si aumentasse dimensione dei blocchi per inglobare più transazioni verrebbero richieste risorse computazionali e di archiviazione tali da escludere la maggior parte dei nodi domestici, portando inevitabilmente a una centralizzazione dei validatori e minando la natura trustless e decentralizzata del sistema.

Per ovviare a tale problema, e superare quello che verrà definito come "trilemma della scalabilità", è emersa la necessità di sviluppare soluzioni di secondo livello. L'idea alla base è spostare la maggior parte delle transazioni "off-chain", ovvero al di fuori della blockchain principale, utilizzando quest'ultima non più come registro di ogni singola attività, ma come giudice finale e imparziale.

Il Lightning Network rappresenta la proposta più promettente e diffusa. Si tratta di una rete di canali di pagamento bidirezionali che permette agli utenti di scambiare fondi istantaneamente e con commissioni minime, aggiornando i saldi privatamente e trasmettendo alla blockchain solo le transazioni di apertura e chiusura del canale. Inoltre, attraverso l'uso di appositi contratti, il Lightning Network consente di instradare pagamenti attraverso nodi intermedi in modo sicuro e senza che questi possano sottrarre i fondi.

Malgrado ciò, come ogni sistema complesso, anche il Lightning Network presenta sfide architetturali. Se da un lato risolve il problema del throughput, dall'altro introduce nuove dinamiche legate alla liquidità, alla topologia della rete e a potenziali rischi di centralizzazione, dove pochi nodi potrebbero arrivare a gestire una porzione significativa del traffico.

\section*{Struttura della tesi}

La struttura dell'elaborato sarà quindi la seguente:
\begin{itemize}
    \item Il \textbf{Capitolo 1} analizza le limitazioni strutturali delle blockchain pubbliche e il trilemma della scalabilità, ponendo le basi per la necessità di soluzioni off-chain.
    \item Il \textbf{Capitolo 2} introduce le primitive crittografiche essenziali per i protocolli di secondo livello, come le funzioni di hash, le firme digitali e i timelocks.
    \item Il \textbf{Capitolo 3} esamina il ruolo di Bitcoin come livello base, focalizzandosi su come la blockchain garantisca la sicurezza dei fondi gestiti nei livelli superiori.
    \item Il \textbf{Capitolo 4} descrive nel dettaglio l'architettura dei canali di pagamento, spiegando i meccanismi di apertura, aggiornamento e chiusura, nonché le strategie per prevenire frodi tra le controparti.
    \item Il \textbf{Capitolo 5} estende l'analisi dal singolo canale all'intera rete Lightning, illustrando come avviene il routing dei pagamenti attraverso nodi intermedi preservando la privacy e la sicurezza.
    \item Infine, il \textbf{Capitolo 6} discute i limiti attuali della tecnologia, presentando un'analisi critica sulla centralizzazione della rete e sulle vulnerabilità sistemiche, delineando le possibili linee di ricerca futura.
\end{itemize}

%----------------------------------------------------------------------------------------
\chapter{Scalabilità delle blockchain e limiti strutturali}
%----------------------------------------------------------------------------------------
Le blockchain pubbliche, e Bitcoin in particolare, hanno dimostrato che è possibile ottenere consenso distribuito in un ambiente privo di fiducia reciproca. Esse hanno introdotto un grande cambio di paradigma nella gestione del valore digitale. Tuttavia, questa nuova soluzione architetturale comporta costi significativi in termini di efficienza.

In questo capitolo verranno analizzati i principi fondamentali che garantiscono la sicurezza di tali sistemi, ponendo l'attenzione a come gli stessi meccanismi di ridondanza e verifica diffusa, necessari per la decentralizzazione, ne limitino strutturalmente la scalabilità. Verrà presentato il cosiddetto "Trilemma della Scalabilità" e si osserverà come un'adozione globale dell'approccio on-chain renda necessaria l'introduzione di soluzioni di secondo livello, per colpa delle limitazioni fisiche di banda e della latenza.

\section{Evoluzione e principi fondamentali delle criptovalute}
Ad oggi, la maggior parte delle transazioni su Internet, e la totalità di esse prima del 2008, avviene tramite l'ausilio di terze entità fidate, quali banche o istituti finanziari, su cui ogni nodo della rete pone la propria fiducia. Sebbene questo modello sia ampiamente funzionante, presenta tutte le debolezze tipiche dei modelli \textbf{trust-based}. Le transazioni infatti non possono essere irreversibili perché gli istituti finanziari devono poter gestire eventuali dispute tra utenti, ma questo rende il denaro elettronico meno \textit{finale} rispetto a quello fisico e crea incertezza per i venditori. Gestire problemi, rimborsi e controlli antifrode genera dei costi aggiuntivi che ogni utente paga sotto forma di \textit{commissioni} rendendo i micropagamenti economicamente sconvenienti. Infine la presenza di un ente centrale rappresenta un \textbf{single point of failure}, ossia un punto critico la cui compromissione può compromettere l'intero sistema.~\cite{nakamoto2008bitcoin}

Lo scopo principale delle criptovalute è invece quello di operare in un ambiente decentralizzato, senza alcuna autorità centrale, basato sulla crittografia, nel quale due nodi della rete possono effettuare delle transazioni tra loro senza la necessità di fidarsi di un intermediario. Le transazioni sono computazionalmente impossibili da invertire e il sistema \textbf{blockchain} protegge dalle frodi sia venditori che i clienti. La validità di ogni operazione è garantita tramite calcoli matematici complessi e può essere verificata da chiunque in qualsiasi momento. La crittografia sostituisce quindi la fiducia verso gli intermediari con una prova matematica, non è necessario fidarsi di banche o istituti finanziari perché la correttezza di ogni operazione è verificabile pubblicamente.\cite{nakamoto2008bitcoin}

La \textbf{blockchain} è una combinazione di elementi crittografici di base come le \textbf{funzioni di hash}, le \textbf{firme digitali} e i protocolli di \textbf{consenso distribuito} (\textit{proof-of-work}), che interagiscono tra loro per creare un sistema sicuro di registrazione delle transazioni.\cite{nakamoto2008bitcoin}
Come evidenziato da Narayanan e Clark \cite{narayanan2017bitcoin}, l'innovazione di Nakamoto non risiede nell'invenzione di nuove primitive crittografiche, quanto nell'aver combinato in modo ingegnoso strumenti preesistenti, con un sistema di incentivi economici, creando il primo sistema realmente funzionante e autonomo.

Il cuore della blockchain su cui si basa Bitcoin è il \textbf{protocollo di gossip}, in cui tutte le modifiche che vengono apportate al registro delle transazioni vengono inviate in broadcast a tutti i nodi partecipanti alla rete. A causa di questo la blockchain di Bitcoin da sola non è in grado di gestire tutte le transazioni che avvengono quotidianamente nel mercato mondiale. Visa, uno dei principali circuiti di pagamento mondiali, utilizzato in oltre duecento paesi, è in grado di gestire picchi di 47000 transazioni al secondo, arrivando quindi ad una media di centinaia di milioni di transazioni al giorno\cite{alston2021constitutions}. Bitcoin, allo stato originale, è in grado di gestire solamente 7 transazioni al secondo, con blocchi di dimensione massima di 1 megabyte. Assumendo di poter avere i blocchi di dimensione infinita, e supponendo di utilizzare circa 300 bytes per ogni transazioni, per attuare la mole di lavoro gestita da Visa, Bitcoin genererebbe blocchi da 8 gigabytes ogni 10 minuti, arrivando quindi a 400 terabyte di dati all'anno.\cite{poon2016lightning}

Chiaramente nessun personal computer sarebbe in grado di gestire tale catena, né a livello di banda, né a livello di quantità di dati da elaborare. Se Bitcoin dovesse diventare il metodo più diffuso di pagamento online, la rete collasserebbe molto velocemente, oppure si creerebbe un fenomeno di estrema centralizzazione, in cui a gestire la rete sono solo i pochi nodi in grado di gestire quel volume di lavoro. Meno nodi gestiscono la rete e meno sarà accurato il registro delle transazioni, inoltre tali nodi potrebbero smettere di agire nell'interesse comune ed iniziare ad agire per il proprio interesse, aumentando i costi di transazione per poter operare scorrettamente. In casi estremi, i nodi non in grado di fare da miner, potrebbero affidare i loro fondi ai nodi più potenti, dandone loro la completa custodia.\cite{poon2016lightning}

Diventa quindi fondamentale che, nel caso in cui Bitcoin diventi estremamente popolare, ogni personal computer, con una normale capacità di calcolo, sia in grado di competere per validare i vari blocchi, risolvendo le criticità che rendono possibile la centralizzazione, e dando modo alle persone di fidarsi di tale sistema.

\section{Il trilemma della scalabilità nei sistemi decentralizzati}
Con l’aumentare delle transazioni, le blockchain pubbliche diventano lente e costose, smettendo di essere un sistema affidabile. La sfida che si sta affrontando è quella di migliorare questi meccanismi senza però dover sacrificare nessuno dei principi fondamentali delle blockchain.

Il \textbf{Trilemma della scalabilità} è un teorema coniato da Vitalik Buterin, cofondatore di Ethereum, che raggruppa i problemi principali a cui gli sviluppatori vanno incontro quando cercano di realizzare una nuova blockchain. Tali problemi sono tre e sono \textit{scalabilità}, \textit{decentralizzazione} e \textit{sicurezza}. Buterin afferma che queste tre siano le proprietà che una qualsiasi blockchain cerca di avere, e, affidandosi a tecniche semplici, sia possibile avere solo due di esse.\cite{buterin2021trilemma}

Tali proprietà sono così definite:
\begin{itemize}
    \item \textbf{Scalabilità:} la blockchain deve essere in grado di elaborare un numero di transazioni maggiore rispetto a quelle che può verificare da solo un normale nodo.
    \item \textbf{Decentralizzazione:} il sistema deve essere \textit{trustless}, non ci deve essere nessun nodo, o nessuno piccolo gruppo di nodi, in cui sia necessario porre la fiducia di ogni elemento della rete. Tale proprietà implica che il livello di fiducia tra i nodi debba essere ridotto al minimo.
    \item \textbf{Sicurezza:} la blockchain deve riuscire a resistere al maggior numero possibile di nodi, partecipanti alla rete, che cercano di attaccarla. Idealmente tale resistenza dovrebbe arrivare almeno al 50\% dei nodi, anche se una catena è considerata valida da sopra il 25\%.
\end{itemize}

La scalabilità è strettamente collegata con la decentralizzazione, ed è il principio cardine sul quale si basano le blockchain, nonostante sia molto complicato ottenerlo.

Mescolando le proprietà si ottengono tre diverse tipologie di sistemi, ognuno dei quali è costretto a sacrificare un principio, proprio come detto nel trilemma della scalabilità:
\begin{itemize}
    \item \textbf{Blockchain tradizionali:} si basano sul fatto che ogni partecipante alla rete sia un nodo a se stante in grado di validare ogni transazione. In questo modo si ottengono decentralizzazione e sicurezza, ma non la scalabilità. Di questa categoria fanno parte Bitcoin, Litecoin e altre catene simili.
    \item \textbf{Catene high-TPS:} si basano su un numero limitato di nodi, tipicamente tra 10 e 100, che mantengono il consenso tra di loro, gli altri nodi della rete devono fidarsi della maggior parte di questi nodi. Questa soluzione ottiene scalabilità e sicurezza, ma è chiaro che non sia decentralizzata.
    \item \textbf{Ecosistemi multi-chain:} si basa sul concetto di \textit{scalabilità orizzontale}, ossia la possibilità di avere più catene e di utilizzare un protocollo di comunicazione per farle comunicare tra loro. Questa soluzione risulta essere decentralizzata e scalabile, ma non sicura. Infatti ad un aggressore basterebbe ottenere la maggioranza dei nodi di consenso di una delle numerose catene per prenderne il controllo e generare problemi a valanga sulle altre.
\end{itemize} \cite{buterin2021trilemma}

La conclusione è che cercare di ottenere scalabilità a livello del protocollo di base, senza compromettere la decentralizzazione e la sicurezza, è incredibilmente difficile con l'architettura attuale. Bitcoin ha scelto di non scendere a compromessi sulla sicurezza e sulla decentralizzazione; di conseguenza, la scalabilità deve essere ricercata altrove.

\section{Off-chain e soluzioni di secondo livello}
Considerando le criticità evidenziate dal \textit{Trilemma della scalabilità} enunciato precedentemente, la comunità scientifica e gli sviluppatori di Bitcoin hanno spostato la loro attenzione verso soluzioni che non richiedono modifiche al protocollo di base, detto \textit{layer 1}. L'idea è quella di fare in modo che la maggior parte delle transazioni avvenga \textbf{off-chain}, ovvero al di fuori della blockchain principale, andando di fatto a costruire un livello superiore in grado di gestire tali transazioni, detto \textit{layer 2}.

Poon e Dryja \cite{poon2016lightning} introducono la possibilità di creare canali di pagamento tra due nodi partecipanti alla rete, che si scambiano denaro senza la necessità di registrare ogni transazione sulla blockchain. Se, per esempio, due nodi si scambiano denaro ogni giorno, e solo a loro interessa di queste transazioni ricorrenti, non è necessario che anche tutti gli altri nodi della catena siano sempre a conoscenza di ogni loro movimento. Così facendo si permette agli utenti di Bitcoin di attuare molteplici transazioni senza far collassare il sistema e senza rischiare di avere problemi di centralizzazione.

La soluzione consiste quindi nel creare questi canali, detti \textbf{canali di micropagamento}, che consentono di inviare grandi quantità di fondi in modo decentralizzato. In questo modo Bitcoin può scalare fino a miliardi di transazioni giornaliere utilizzando la potenza di calcolo di un normale laptop odierno.

I canali di micropagamento instaurano una relazione tra due parti, che aggiornano costantemente i propri saldi, evitando di passare sempre per la blockchain e registrando su di essa solo la transazione finale, figlia di tutte quelle precedenti avvenute off-chain. Questi canali non sono da intendere come reti separate da Bitcoin, ma rappresentano vere e proprie transazioni Bitcoin. Scegliere di inviare sulla blockchain principale un'unica transazione finale permette ad entrambe le parti di garantire il proprio saldo sulla rete.

Il funzionamento logico di base di questo meccanismo è il seguente:
\begin{enumerate}
    \item \textbf{Apertura:} Due nodi bloccano una somma di denaro comune in una transazione sulla blockchain. Questo è l'unico momento in cui la rete globale viene coinvolta inizialmente. Questa transazione di apertura viene chiamata \textit{Funding Transaction}.
    \item \textbf{Operatività Off-Chain:} Le parti possono scambiarsi un numero illimitato di transazioni aggiornando privatamente la ripartizione dei fondi bloccati. Queste operazioni sono istantanee e non richiedono commissioni di mining, poiché sono semplici scambi di dati firmati crittograficamente tra i due utenti.
    \item \textbf{Chiusura:} Quando le parti decidono di terminare la collaborazione, l'ultimo stato del bilancio viene inviato alla blockchain per la transazione finale. Non è necessario che entrambi i nodi richiedano di chiudere il canale, basta solo una delle due parti.
\end{enumerate}

In questo modello, la blockchain non agisce più come un registro contabile di ogni singola transazione, ma assume il ruolo di un giudice imparziale che interviene solo in caso di disputa o alla fine del rapporto economico tra le parti.

%----------------------------------------------------------------------------------------
\chapter{Primitive crittografiche per i protocolli off-chain}
%----------------------------------------------------------------------------------------
La sicurezza e il funzionamento dei protocolli di secondo livello non si basano sulla fiducia verso terze parti, ma sull'utilizzo combinato di specifiche primitive crittografiche. Mentre la blockchain di Bitcoin utilizza queste tecnologie per garantire il consenso globale, il Lightning Network le impiega per creare contratti intelligenti, detti \textit{Smart Contracts}, che permettono l'esecuzione sicura delle transazioni off-chain.

In questo capitolo verranno analizzati gli strumenti fondamentali necessari alla costruzione di un canale di pagamento: le \textit{funzioni di hash} per la creazione di vincoli condizionali, le \textit{firme digitali} per la gestione condivisa dei fondi e i \textit{vincoli temporali} per la gestione delle dispute.

\section{Funzioni di hash crittografico e loro proprietà}
Le funzioni di hash svolgono un ruolo fondamentale nella crittografia moderna e hanno numerose applicazioni nell'ambito della sicurezza informatica. Sono infatti utilizzate per esempio per:
\begin{itemize}
    \item Firme digitali
    \item Verifica dell'integrità dei file
    \item Sicurezza delle password
    \item Blockchain
    \item SSL/TLS protocolli
\end{itemize}
Una funzione di hash è una funzione \textbf{non invertibile} che trasforma una sequenza di bit di lunghezza arbitraria in una sequenza di bit di lunghezza predefinita, chiamata \textbf{digest}.

Le funzioni di hash specifiche per gli ambiti crittografici devono avere le seguenti proprietà:
\begin{itemize}
    \item \textbf{Determinismo} $\rightarrow$ lo stesso input inserito nella stessa funzione hash deve dare come risultato lo stesso output
    \item \textbf{Efficienza} $\rightarrow$ il valore hash deve venir calcolato rapidamente, indipendentemente dalla dimensione dell'input
    \item \textbf{Non invertibilità} $\rightarrow$ dato un digest non deve essere possibile risalire all'input che lo ha generato
    \item \textbf{Effetto valanga} $\rightarrow$ piccole modifiche nel messaggio di input determinano modifiche significative, apparentemente non correlate, nell'hash di output
\end{itemize} \cite{stallings2017cryptography}

Ognuna di queste caratteristiche è essenziale per rendere la funzione crittograficamente sicura. La problematica principale a cui queste funzioni devono essere in grado di resistere sono le \textbf{collisioni}. Avviene una collisione ogni volta che due input differenti generano lo stesso output. Di base, se un algoritmo genera delle collisioni significa che non è un algoritmo sicuro. \cite{stallings2017cryptography}

La famiglia di funzioni crittografiche di hash più utilizzata ad oggi è la \textbf{SHA}, \textit{Secure Hash Algorithm}, i vari algoritmi che ne fanno parte si distinguono per differenza di lunghezza del \textit{digest} e resistenza alle collisioni:
\begin{itemize}
    \item \textbf{SHA-1} $\rightarrow$ è stato l'algoritmo più usato della famiglia sha, diffuso in numerose applicazioni e protocolli nonostante ormai sia considerato insicuro, dato che la sua sicurezza è stata compromessa dai crittoanalisti. Produce un \textit{digest} di 160 bit, da un input lungo massimo $2^{64}-1$ bit.
    \item \textbf{SHA-2} $\rightarrow$ Nei primi anni 2000 vengono pubblicate dal NIST altre quattro funzioni di hash, ognuna con un \textit{digest} più lungo di quello originale. A far parte di questo sottogruppo sono \textbf{SHA-224}, \textbf{SHA-256}, \textbf{SHA-384} e \textbf{SHA-512}, che generano \textit{digest} rispettivamente di 224, 256, 384 e 512 bit. Gli algoritmi \textbf{SHA-256} e \textbf{SHA-512} lavorano rispettivamente con \textit{word} di 32 e 64 bit. La loro struttura è sostanzialmente identica anche se utilizzano un differente numero di rotazioni e di costanti addizionali. Gli altri due algoritmi, invece, sono semplicemente delle versioni troncate di questi, con hash calcolati con differenti valori iniziali. La sicurezza della famiglia SHA-2 è oggi considerata solida; tuttavia, la sua struttura è stata meno analizzata rispetto a SHA-1 prima della sua compromissione, motivo per cui il NIST ha promosso lo sviluppo di SHA-3.
    \item \textbf{SHA-3} $\rightarrow$ Nuovo membro della famiglia SHA trovato grazie ad un competizione lanciata dal NIST nel 2007, con l'obiettivo di sviluppare una nuova funzione di hashing per rafforzare le versioni precedenti.
\end{itemize} \cite{stallings2017cryptography}

L'algoritmo SHA-256 riveste un ruolo centrale nel protocollo Bitcoin: viene infatti utilizzato per calcolare l'hash di ciascun blocco, per collegare i blocchi della catena tra loro e, soprattutto, nel meccanismo di \textbf{Proof-of-Work}, dove i miner devono trovare un valore di nonce tale che l'hash del blocco risulti inferiore a una soglia prefissata, detta \textit{target}. 
Quindi è anche grazie a questo algoritmo se il sistema riesce a resistere alle modifiche retroattive e a garantire l'integrità della blockchain.

Nel contesto delle criptovalute, in particolare Bitcoin, ogni transazione e ogni blocco della blockchain vengono identificati da un hash calcolato applicando due volte la funzione di SHA-256, il processo si chiama \textbf{double hashing}. Questa doppia applicazione serve a ridurre la probabilità di collisioni e proteggere da eventuali attacchi. \cite{antonopoulos2017mastering}

Nel contesto specifico del Lightning Network, tuttavia, l'uso più rilevante delle funzioni di hash non è legato al mining o alla struttura a blocchi, ma alla creazione di vincoli condizionali per i pagamenti.

La proprietà di \textit{resistenza alla preimmagine} viene sfruttata per generare segreti crittografici fondamentali per il routing sicuro. Il meccanismo, che costituisce la base degli \textbf{Hashed Time-Lock Contracts (HTLC)}, funziona nel seguente modo:
\begin{enumerate}
    \item Il destinatario di un pagamento genera un numero casuale $R$, detto \textit{pre-image} o segreto.
    \item Viene calcolato l'hash di questo segreto: $H = \text{SHA-256}(R)$, denominato \textit{payment hash}.
    \item L'hash $H$ viene condiviso pubblicamente con il mittente e con la rete, mentre $R$ rimane segreto fino al momento dell'incasso.
\end{enumerate}

I fondi vengono vincolati a $H$ tramite uno smart contract: essi possono essere spesi solo da chi è in grado di rivelare la preimmagine $R$ che, passata attraverso la funzione SHA-256, restituisce l'hash $H$ specificato nel contratto. Data l'unidirezionalità della funzione, è computazionalmente impossibile per un attaccante risalire a $R$ conoscendo solo $H$, garantendo così che solo il legittimo destinatario possa sbloccare i fondi \cite{antonopoulos2017mastering}.

\section{Firme digitali e firme multiple}
\subsection{Firme digitali}
Le firme digitali vengono create per permettere ai sistemi di elaborazione di accertare l'identità di un utente. Il destinatario di un messaggio, o di una somma di denaro, deve poter essere in grado di verificare l'identità del mittente e l'integrità di ciò che ha ricevuto, dunque il metodo utilizzato deve rendere difficile ad un intruso di spacciarsi per qualcun altro o di modificare i messaggi inviati.

La firma digitale entra in gioco proprio nei sistemi \textit{trustless}, quando il mittente e il destinatario non si fidano l'uno dell'altro. Il meccanismo, per essere valido, deve rispettare i seguenti tre requisiti:
\begin{enumerate}
\item \textbf{Non ripudio}$\rightarrow$ non deve essere permesso ad un mittente di negare di aver mandato un messaggio da lui firmato
\item \textbf{Autenticazione e integrità}$\rightarrow$ il destinatario deve poter autenticare il messaggio, ossia accertare l'identità del mittente e l'integrità del messaggio ricevuto
\item \textbf{Irrefutabilità della ricezione}$\rightarrow$ il destinatario non deve poter sostenere di aver ricevuto un messaggio diverso da quello inviatogli dal mittente
\end{enumerate} \cite{stallings2017cryptography}

Il meccanismo crittografico adottato da Bitcoin si chiama \textbf{Elliptic Curve Digital Signature Algorithm}, ossia \textbf{ECDSA}. Con esso vengono firmate digitalmente le transazioni ed ogni nodo può dimostrare il possesso della propria chiave privata, senza però andare a rivelarla. Le chiavi private in Bitcoin sono molto importanti, perchè è con esse che si dimostra il possesso di una certa quantità di monete, se la chiave viene persa anche i fondi a lei associati saranno perduti, mentre se viene rubata consente di spendere il denaro dell'utente.

ECDSA si basa sulla crittografia a \textbf{curve ellittiche}, una variante della crittografia asimmetrica che riesce ad ottenere lo stesso livello di sicurezza di algoritmi come RSA utilizzando chiavi molto più piccole, risultando quindi più efficiente. \cite{antonopoulos2017mastering}

La \textbf{chiave privata} di ogni utente viene scelta randomicamente in un intervallo definito, e la \textbf{chiave pubblica} viene derivata tramite un'operazione matematica detta \textbf{moltiplicazione scalare} su una curva ellittica. La curva adottata da Bitcoin è la \textbf{secp256k1}, che opera su un campo finito di 256 bit, scelta per la sua semplicità ed efficienza. \cite{sec2_2010}

La sicurezza del sistema si basa sulla difficoltà computazionale di risalire alla chiave privata di determinato utente conoscendo solo quella pubblica, ossia risolvere il \textbf{problema del logaritmo discreto su curve ellittiche}.

Durante una firma, l'algoritmo genera una coppia di valori partendo dal messaggio e dalla chiave privata del nodo in questione, questi due numeri costituiscono quindi la firma digitale. Chiunque può verificarne la veridicità utilizzando la chiave pubblica del mittente.

ECDSA garantisce l'autenticità e la non ripudiabilità delle transazioni, rendendo possibile un sistema di scambio decentralizzato.
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth, keepaspectratio]{figures/ecdsa.png} 
    \caption[Schema ECDSA]{Schema logico della firma digitale ECDSA. La chiave privata firma l'hash del messaggio; la chiave pubblica permette la verifica senza rivelare il segreto. (Fonte: rielaborazione da Scrypt Platform)}
    \label{fig:ECDSA}
\end{figure}

\subsection{Firme multiple}
Per implementare un sistema complesso come il Lightning Network richiede meccanismi avanzati e di conseguenza le firme singole non bastano più. Per gestire la proprietà condivisa dei canali sono richieste le \textbf{firme multiple}, o \textbf{multisig}, che permettono di vincolare i fondi ad un gruppo di persone.

In questa tipologia di schemi viene impostata una condizione per cui nello script di output vengono registrate $k$ chiavi pubbliche ed almeno $t$ di queste devono fornire una firma valida per spendere i fondi. Schemi come questo vengono definiti come $t$-of-$k$. Per esempio in una firma multipla 2-of-3 ci sono tre potenziali chiavi pubbliche, ed almeno due di queste devono essere usate per creare una firma valida per spendere i fondi. \cite{antonopoulos2017mastering}

Nel contesto del Lightning Network, viene utilizzato uno schema 2-of-2. Quando due utenti aprono un canale di pagamento, creano una transazione di finanziamento, la \textit{Funding Transaction}, verso un indirizzo multisig controllato congiuntamente. Dal momento in cui il canale è stato creato, la regola imposta dalla blockchain è semplice e stretta: per muovere quei fondi è necessario il consenso di entrambe le parti, questo si traduce nella necessità che entrambe le parti firmino le modifiche allo stato dei fondi.

Questa architettura agisce come una garanzia di sicurezza preventiva:
\begin{itemize}
    \item Nessuna delle parti può sottrarre i fondi all'altra, poiché mancherebbe la seconda firma necessaria.
    \item In caso di disaccordo, i fondi rimangono bloccati.
\end{itemize}
In realtà, per quanto riguarda questo ultimo punto, nel protocollo sono previsti meccanismi di uscita che permettono di risolvere la disputa, come i \textit{timelock}, che verranno descritti successivamente. \cite{poon2016lightning}

In sintesi, il Multisig rende i fondi vincolati in un canale condivisi, costringendo le parti a cooperare per aggiornare lo stato del canale.

\section{Vincoli temporali nelle transazioni}
Nei sistemi di pagamento tradizionali l'obiettivo è rendere il denaro derivante da una transazione immediatamente spendibile; nei sistemi complessi come il Lightning Network, invece, è necessario che i fondi derivati da una transazione non siano spendibili immediatamente, questo per evitare truffe e frodi.

Verrà chiarito in seguito come il non permettere di spendere subito i fondi derivanti da una transazioni sia una misura di sicurezza che permette alla controparte del canale di realizzare di aver subito una truffa e di agire di conseguenza.

Diventa quindi necessario gestire il tempo all'interno delle transazioni. Quest'ultimo nella blockchain di Bitcoin non è misurato prevalentemente in secondi, ma in \textbf{altezza di blocco}, \textit{Block Height}, sebbene sia possibile utilizzare anche il timestamp Unix. Poiché un blocco viene minato in media ogni 10 minuti, definire un intervallo di 144 blocchi equivale a circa 24 ore.

Entrano quindi in gioco i \textbf{timelock}. Ne esistono due tipi:
\begin{itemize}
    \item \textbf{Timelock assoluti:} rendono una transazione non valida per la rete fino ad un determinato punto nel futuro, ad esempio fino al blocco 850.000.
    A livello di script, questi sono implementati tramite l'opcode \textbf{\texttt{OP\_CHECKLOCKTIMEVERIFY}} (CLTV), introdotto con il BIP 65 \cite{bip65}.
    Questi vengono utilizzati per i \textbf{rimborsi}. Come detto precedentemente, quando due nodi aprono un canale bloccano dei fondi con la \textit{Funding Transaction}, questa rende tali fondi comuni ed impone la necessità della firma di entrambe le parti per fare un qualsiasi movimento. Se un nodo, una volta creato il canale, smette di rispondere, o va offline perennemente, l'altro, dopo un determinato periodo, può recuperare i fondi che aveva bloccato grazie a una transazione che diviene valida solo allo scadere del timelock. \cite{antonopoulos2017mastering}
    \item \textbf{Timelock relativi:} introdotti con il BIP 112 \cite{bip112} tramite l'opcode \textbf{\texttt{OP\_CHECKSEQUENCEVERIFY}} (CSV), essi non guardano una data fissa nel calendario, ma l'età dell'output che si sta spendendo. Questo tipo di timelock impone la seguente condizione: una transazione $X$ che spende un output $Y$ è valida se e solo se sono passati $n$ blocchi dalla conferma di $Y$ sulla blockchain.
    Vengono utilizzati nel caso di \textbf{dispute}, e sono l'elemento centrale del meccanismo di sicurezza del Lightning Network. Tenendo bloccati i fondi per un certo numero di blocchi, un'eventuale vittima può accorgersi di essere stata truffata e creare una finestra di contestazione. La vittima ha tempo a sufficienza per accorgersi del tentativo di frode e, utilizzando una chiave di revoca, prelevare l'intera somma prima che il timelock scada e il truffatore possa incassare. \cite{antonopoulos2017mastering}
\end{itemize}

%----------------------------------------------------------------------------------------
\chapter{Bitcoin come livello base di sicurezza}
%----------------------------------------------------------------------------------------
Nel capitolo precedente sono state analizzate le primitive crittografiche necessarie per la costruzione di contratti condizionali e canali di pagamento. Tuttavia, per ottenere un sistema funzionante, sicuro e soprattutto \textit{trustless}, gli elementi appena trattati, da soli, non bastano. Sorge quindi la necessità di un'infrastruttura sottostante, in grado di interpretarli ed eseguirli in modo inappellabile.

Il protocollo originale di Bitcoin, a questo punto, non è più utilizzato solo come valuta digitale, ma assume un ruolo cruciale, diventando un arbitro imparziale per le \textit{dispute}.
Come teorizzato nel whitepaper di Satoshi Nakamoto \cite{nakamoto2008bitcoin}, la blockchain risolve il problema della doppia spesa attraverso una catena di prove crittografiche basate sul lavoro computazionale. Per le soluzioni di secondo livello come il Lightning Network, questa proprietà di immutabilità è fondamentale: la blockchain principale diventa l'ente a cui le parti si rivolgono solo in caso di controversia o per finalizzare gli scambi avvenuti privatamente.

Come detto nei capitoli precedenti, è importante sottolineare che le transazioni eseguite nel Lightning Network non sono alternative a Bitcoin, ma sono vere e proprie transazioni Bitcoin valide, la differenza è che queste vengono trattenute dai nodi e non sono trasmesse immediatamente alla rete globale. La sicurezza di questi scambi \textit{off-chain} deriva interamente dalla certezza che, in qualsiasi momento, lo stato corrente del canale possa essere pubblicato e confermato sulla blockchain principale.

Questo capitolo analizzerà le componenti strutturali di Bitcoin che rendono possibile tale architettura. In primo luogo, verrà esaminata la struttura delle transazioni, successivamente, si discuterà il ruolo della Proof-of-Work non solo come meccanismo di consenso, ma come orologio universale per la gestione dei vincoli temporali. Infine, verrà trattata l'evoluzione del protocollo con l'introduzione di Segregated Witness (SegWit), un aggiornamento critico che, risolvendo la vulnerabilità della \textit{transaction malleability}, ha reso possibile l'implementazione sicura ed efficiente dei canali di pagamento moderni.

\section{Struttura delle transazioni}
Le \textbf{transazioni} permettono ai nodi di scambiarsi i Bitcoin \cite{conoscenti2019payment}, la possibilità di attuare tali operazioni è un aspetto fondamentale per una moneta elettronica. Senza transazioni i vari proprietari di monete non potrebbero scambiarsele tra loro e si andrebbe dunque a perdere il concetto di moneta stessa.

Ogni utente possessore di bitcoin può trasferire una certa quantità di valuta ad un altro utente andando ad apporre la propria firma digitale sull'hash della transazione precedente e la chiave pubblica del nuovo proprietario.

Sorge però un problema: un qualsiasi utente non può verificare che un possessore di bitcoin che ha appena effettuato una transazione non abbia già speso quelle monete altre volte, ossia non abbia effettuato un \textbf{double-spending}. Di fatto il denaro digitale può essere duplicato senza alcuna fatica, proprio come qualsiasi altro oggetto digitale.\cite{conoscenti2019payment}

Bisogna quindi trovare un modo per dimostrare ai beneficiari di una transazione che le monete che stanno ricevendo non sono già state spese. Il sistema di moneta digitale introdotto da David Chaum nel 1983, noto come eCash \cite{chaum1983blind}, è il primo a risolvere il problema della doppia spesa, ma in un ambiente centralizzato, di conseguenza Bitcoin è il primo metodo di pagamento digitale in grado di risolvere questo problema in maniera totalmente decentralizzata.

Per fare ciò tutti i nodi della rete devono essere a conoscenza di tutte le transazioni che sono state eseguite fino a quel momento e devono essere tutti d'accordo sull'ordine cronologico in cui sono avvenute, dunque tutte le transazioni devono essere pubbliche.

Per accordare ogni nodo sull'ordine cronologico si utilizza un \textbf{timestamp server} che prende in input un insieme di dati e ne calcola l'hash per poi pubblicarlo. Rendendo l'hash pubblico chiunque può verificare che quei dati dovevano già esistere al momento della pubblicazione. Ogni nuovo timestamp include anche l'hash del precedente in modo tale da creare una blockchain.

In sintesi il timestamp server è usato per creare una prova temporale immutabile dell'esistenza dei dati.~\cite{nakamoto2008bitcoin}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/transazioni.png}
    \caption{Struttura di una transazione Bitcoin composta da input e output. Ogni input fa riferimento a un output non speso di una transazione precedente. Fonte: Nakamoto\cite{nakamoto2008bitcoin}.}
    \label{fig:tx_structure}
\end{figure}


\subsection{I satoshi}
I \textbf{satoshi} sono l'unità più piccola utilizzabile nel protocollo originale di Bitcoin \cite{antonopoulos2017mastering}. La relazione che intercorre tra bitcoin e satoshi è la seguente:
\begin{equation}
1 \text{ sat} = 10^{-8} \text{ BTC} = 0,00000001 \text{ BTC}
\end{equation}
L'evoluzione verso soluzioni di secondo livello, come il Lighting Network, ha reso necessaria una granularità ancora maggiore, introducento così i \textbf{millisatoshi}, o \textbf{msat}. questa suddivisione è fondamentale per permettere il calcolo di commissioni di routing estremamente basse \cite{bolt1_protocol}. I \textit{msat} seguono la relazione sottostante:
\begin{equation}
1 \text{ msat} = 10^{-3} \text{ sat} = 10^{-11} \text{ BTC}
\end{equation}

\subsection{Il modello UTXO}
A differenza dei sistemi bancari tradizionali o di altre tipologie di monete virtuali, Bitcoin non utilizza un modello basato sui conti o sul portafoglio. Il software dà l'impressione che le monete vengano spostate da un portafoglio ad un altro, quando in realtà queste si muovono di transazione in transazione. Ognuna di esse spende i \textbf{satoshi} ricevuti, che sono gli output di una o più transazioni passate. L'output si ogni transazioni può essere suddiviso in più parti, per permettere di spedire i fondi a nodi differenti, ma ognuna di queste parti è e deve essere spendibile una sola volta \cite{antonopoulos2017mastering}.

Nello specifico, ogni output è univocamente identificato tramite il \textbf{Transaction Identifier} (TXID), ovvero l'hash della transazione firmata da cui ha origine. Poiché ogni singolo output può essere speso una sola volta, l'insieme di tutti gli output registrati sulla blockchain può essere categorizzato in due insiemi disgiunti: gli output già spesi e gli output non ancora spesi, definiti \textbf{Unspent Transaction Outputs (UTXO)}. Una transazione risulta valida se e solo se essa utilizza esclusivamente UTXO esistenti come propri input.

Eccezion fatta per le transazioni di \textit{coinbase}, ovvero le transazioni create dei miner per introdurre nuova moneta del sistema, il protocollo impone un rigoroso bilancio:
se il valore totale degli output di una transazione eccede quello dei suoi input, la transazione viene considerata invalida e rigettata dalla rete. Al contrario, qualora il valore degli input sia superiore a quello degli output, la differenza viene interpretata come commissione di transazione, detta \textit{transaction fee}, e può essere riscossa dal miner che include la transazione all'interno di un blocco.

Questo modello presenta proprietà fondamentali per i protocolli di secondo livello. In particolare:
\begin{itemize}
    \item Ogni stato di un canale di pagamento può essere rappresentato come una possibile spesa futura degli UTXO bloccati nella transazione di funding.
    \item La spesa concorrente di uno stesso UTXO è impossibile per costruzione, eliminando alla radice il problema del double-spending.
    \item Gli UTXO permettono di vincolare fondi tramite script arbitrari, consentendo la realizzazione di contratti condizionali.
\end{itemize}

Come osservato da Poon e Dryja \cite{poon2016lightning}, la possibilità di bloccare e successivamente ridistribuire UTXO condivisi è il meccanismo alla base dei canali di pagamento.

\begin{figure}[h!]
    \centering
    \includegraphics[width=\textwidth]{figures/propTransaction.png}
    \caption{Propagazione e validazione di una transazione nella rete Bitcoin. Ogni nodo verifica la correttezza della transazione prima di propagarla ulteriormente. Fonte: Bitcoin Developer Documentation \cite{bitcoin_dev_blockchain}.}
    \label{fig:tx_propagation}
\end{figure}

\subsection{Transazioni e script di spesa}
In Bitcoin è importante distinguere tra la struttura di una transazione e le condizioni che ne regolano la spendibilità. Una transazione definisce quali UTXO vengono consumati e quali nuovi output vengono creati, ma non contiene logica esecutiva complessa. Le regole che determinano chi e quando può spendere un output sono invece espresse tramite \textbf{Bitcoin Script}, un linguaggio di scripting basato su uno stack, abbastanza limitato. \cite{antonopoulos2017mastering}.

Questa scelta progettuale riduce la superficie di attacco del protocollo e garantisce che il comportamento delle transazioni sia deterministico e facilmente verificabile dai nodi della rete. Ogni output contiene uno script di blocco, lo \textit{scriptPubKey}, mentre per spendere tale output è necessario fornire uno script di sblocco, \textit{scriptSig}, che soddisfi le condizioni imposte.

Nel Lightning Network, Bitcoin Script viene utilizzato per costruire contratti condizionali che combinano firme multiple, vincoli temporali e segreti crittografici. Sebbene il linguaggio non permetta smart contract complessi, la sua semplicità consente di implementare canali di pagamento sicuri senza compromettere la decentralizzazione del layer base \cite{poon2016lightning}.


\section{Struttura dei blocchi}
Ogni blocco della blockchain di Bitcoin è costituito da due sezioni:
\begin{itemize}
    \item \textbf{Block header} $\rightarrow$ l'intestazione del blocco.
    \item \textbf{Block body} $\rightarrow$ l'elenco delle transazioni appartenenti al blocco.
\end{itemize}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/blockBitcoin.png}
    \caption{Struttura di un blocco Bitcoin. Le transazioni sono organizzate in un Merkle tree, il cui hash radice è incluso nell’header del blocco. Fonte: Provino, rielaborazione da \cite{provino_merkle}.}
    \label{fig:block_structure}
\end{figure}

Le informazioni contenute nell'intestazione sono necessarie a collegare i vari blocchi tra loro e a verificarne la validità. Nella figura \ref{fig:block_structure} possiamo vedere quali sono gli elementi che compongono l'header di un tipico blocco della blockchain di Bitcoin:
\begin{itemize}
    \item \textbf{Version} $\rightarrow$ 4 bytes, indica la versione corrente del blocco e dunque le regole di validazione che esso sta seguendo.
    \item \textbf{PrevHashBlock}$\rightarrow$ 32 bytes, rappresenta il doppio hash del header del blocco precedente, necessario per rendere tale struttura una catena. Garantisce che nessun blocco precedente possa essere modificato senza modificare anche l'intestazione di questo. Ovviamente l'unico blocco che non ha un predecessore è il primo, che viene chiamato \textbf{genesis block}.
    \item \textbf{MerkleRootHash} $\rightarrow$ 32 bytes, è il doppio hash della root dell'albero di Merkle composto da tutte le transazioni appartenenti al blocco in questione. Modificare una transazione significa anche modificare questo elemento del blocco.
    \item \textbf{Timestamp} $\rightarrow$ 4 bytes, timestamp approssimato della creazione del blocco. Deve essere maggiore del timestamp medio degli 11 blocchi precedenti.
    \item \textbf{Bits/Target} $\rightarrow$ 4 bytes, codifica compatta della difficoltà richiesta per trovare un hash valido per risolvere il blocco.
    \item \textbf{Nonce} $\rightarrow$ 4 bytes, numero arbitrario trovato dai miners che rende l'hash del blocco valido, ossia inferiore al target. Se tutti i valori a 32 bit vengono tentati si può aggiornate il timestamp o la Merkle root.
\end{itemize}

I Merkle tree permettono di rappresentare in modo compatto l’insieme delle transazioni incluse in un blocco. Attraverso una struttura ad albero basata su funzioni hash, è possibile verificare l’appartenenza di una singola transazione al blocco senza dover scaricare l’intero contenuto, proprietà fondamentale per i nodi leggeri. \cite{provino_merkle}

Per quanto riguarda invece il body del blocco si nota che il primo elemento all'interno dell'elenco delle transazioni e la cosiddetta \textbf{coinbase transaction}, ossia i nuovi bitcoin che sono stati generati e dati come ricompensa al miner che ha risolta il blocco in questione. Questo meccanismo, noto come \textbf{block reward}, rappresenta l'unico modo con cui vengono emessi nuovi bitcoin nel sistema. ~\cite{bitcoin_dev_blockchain}

La struttura dei blocchi e la loro concatenazione tramite Proof-of-Work forniscono una nozione condivisa di tempo e finalità, che viene sfruttata direttamente dai protocolli di secondo livello per gestire vincoli temporali e risolvere eventuali dispute.

\section{Proof-of-Work: meccanismo di consenso e arbitraggio}
Nel protocollo originiale di Nakamoto \cite{nakamoto2008bitcoin}, la \textbf{Proof of Work} è il meccanismo adottato per garantire la sicurezza dalla rete, impedire il \textit{double spending} e confermare le transazioni attraverso un processo di competizione tra i miner che richiede un enorme potenza di calcolo e di energia. La funzione principale della PoW è quindi quella di rendere estremamente costoso e impraticabile per un malintenzionato manomettere la rete.

Per il Lighting nNetwork questo meccanismo è fondamentale perché garantisce sicurezza e veridicità sulla blockchain, e la rende immutabile. Inoltre tale sistema viene anche utilizzato come orologio centrale, dato che esso genera un blocco ogni dieci minuti. \cite{antonopoulos2022masteringLN}

I \textbf{miner} sono computer, tipicamente dotati di molta potenza, che convalidano le transazioni risolvendo i vari blocchi ed aggiungendoli alla blockchain. Per fare ciò competono per risolvere problemi crittografici complessi e colui che risolve il problema per primo viene ricompensato con nuove unità di Bitcoin. \cite{mining_tech_paper}

La \textbf{Proof of Work} consiste nel trovare un valore di \textit{Nonce} che permetta all'hash del blocco di iniziare con un numero predefinito di zeri. Tale numero viene rappresentato dal valore \textit{Target} nell'header di ogni blocco. La quantità di lavoro richiesta per risolvere il problema è esponenziale rispetto al numero di zeri richiesti, ma, una volta trovata la soluzione, ogni nodo della rete può verificare con facilità la validità del blocco. \cite{nakamoto2008bitcoin}

Ogni miner deve dunque risolvere il seguente problema:
\[
H = \text{SHA256}\big(\text{SHA256}(\text{BlockHeader}(N))\big)
\]
\[
\text{Trovare } N \text{ (nonce) tale che } H < T \text{ (target)}       \cite{mining_tech_paper}
\]

Come detto nei capitoli precedenti una delle caratteristiche che rende così gettonate le funzioni di hash è l'impossibilità di risalire all'input conoscendo il risultato. È proprio questa la proprietà su cui si basa la Proof of Work, infatti, quello di trovare un double hash per il blocco che contenga un determinato numero di zeri iniziali è un problema che può essere risolto solo a tentativi. Nessun miner è in grado di costruire artificialmente un \textit{nonce} in grado di risolvere il blocco. Una volta che la soluzione è stata trovata però tutti i nodi sono in grado di calcolare l'hash del blocco e verificare che esso rispetti il numero di zeri richiesto. \cite{hash_intro_paper}

La \textbf{PoW} risolve anche un altro problema fondamentale: quello di determinare in modo affidabile la rappresentanza nella decisione di maggioranza. La fiducia nella \textbf{blockchain} si basa sul \textbf{consenso distribuito}, infatti un nuovo blocco può essere aggiunto alla catena solo quando la maggioranza dei partecipanti della rete concorda sulla sua validità. Se per rappresentare la maggioranza venisse utilizzato un meccanismo \textit{one-IPaddress-one-vote} il sistema sarebbe nella mani di chi è in grado di allocare in maggior numero di indirizzi IP. Invece la PoW si basa su un meccanismo \textbf{\textit{one-CPU-one-vote}}, quindi la catena considerata valida è la catena più lunga, ovvero quella che incorpora la maggior quantità di lavoro computazionale. Se la maggioranza della potenza delle CPU è rappresentata da nodi onesti vuol dire che la loro catena crescerà più velocemente rispetto a catene fasulle generate da nodi non onesti. Per modificare un blocco passato della catena corrente un malintenzionato dovrebbe ricalcolare la PoW di tutti i blocchi successivi e riuscire anche a superare la crescita della blockchain originale. \cite{nakamoto2008bitcoin}

Per compensare all'aumento di velocità, la potenza hardware e le variazioni nel numero di nodi attivi nel tempo, la \textbf{difficoltà} della proof-of-work viene regolata tramite una \textbf{media mobile} che mantiene costante il numero medio di blocchi generati per ora. Se i nuovi blocchi vengono prodotti troppo rapidamente, la difficoltà verrà aumentata. Essa rappresenta il \textit{numero di zeri iniziali richiesti nel doppio hash} e questo valore è memorizzato nel campo \textbf{nBits/Target}.

Ogni nodo conosce la difficoltà corrente leggendone il valore dall'header dell'ultimo blocco valido della blockchain. Tipicamente la difficoltà viene aggiornata ogni 2016 blocchi, per mantenere una media costante di un blocco ogni 10 minuti, fondamentale per il Lightning Network. \cite{mining_tech_paper}

Il campo \textbf{nBits/Target}, presente nell'header di ciascun blocco, rappresenta una \textit{codifica compatta} del valore di \textbf{target}, ovvero la soglia numerica a cui l'hash doppio SHA-256 del blocco deve risultare inferiore o uguale per essere considerato valido.  
Il valore \texttt{nBits} è composto da:
\begin{itemize}
  \item una \textbf{mantissa} ($m$), che occupa i 3 byte meno significativi,
  \item un \textbf{esponente} ($e$), rappresentato dal byte più significativo.
\end{itemize}
Il target effettivo si ottiene espandendo tale valore compatto secondo la formula:
\[
\text{target} = m \times 2^{8(e - 3)}.
\]

Più piccolo è il valore del target, maggiore sarà la difficoltà richiesta per trovare un hash valido, questo perché un target più basso richiede che l’hash si trovi in una porzione sempre più piccola dello spazio di output di SHA-256 \cite{mining_tech_paper}.

La \textbf{Proof-of-Work} è un meccanismo di sicurezza robusto ma poco efficiente, che ha garantito la sopravvivenza e l'integrità di Bitcoin a scapito della sua sostenibilità \cite{poon2016lightning}. Di seguito verranno trattate le principali problematiche:

\paragraph{Consumo energetico}
Il limite principale della Proof-of-Work è l'elevato consumo energetico. Il mining richiede una potenza di calcolo sempre maggiore per mantenere il tempo medio di generazione dei blocchi, comportando enormi sprechi di energia elettrica. Col tempo questo ha sollevato preoccupazioni ambientali e portato alla ricerca di modelli e strutture alternative. Di fatti l'\textbf{hash rate} di Bitcoin è dell'ordine di $10^{20}$ hash al secondo e, considerando tutti i miner, il consumo energetico totale per l'elaborazioni è vicino a quello di un paese con oltre \textit{45 milioni} di abitanti\cite{tse2022_lecture15_pos} . Sebbene una percentuale significativa di tale energia provenga da fonti rinnovabili, si tratta comunque di una grossa spesa. \cite{kufeoglu2019_energy_consumption_bitcoin}

\paragraph{Scalabilità limitata}
I blocchi possono contenere solo una ridotta quantità di transazioni ciascuno e il tempo medio di generazione di un singolo blocco è di circa \textit{10 minuti}. Questo rappresenta un vincolo importante che impedisce a Bitcoin di competere o sostituire i tradizionali metodi di pagamento \cite{tse2022_lecture15_pos}.\\

Queste limitazioni, insite nel \textit{Layer 1}, non rappresentano un fallimento del protocollo, ma una scelta progettuale per massimizzare la sicurezza. Tuttavia, esse rendono indispensabile lo spostamento della logica dei micropagamenti verso soluzioni di secondo livello, come il \textbf{Lightning Network}, che però sfrutta questo meccanismo a suo vantaggio. Il fatto che esso renda economicamente proibitivo riscrivere la storia della blockchain garantisce che gli stati dei canali pubblicati on-chain abbiano una finalità temporale affidabile, rendendo sicuri i meccanismo di timelock e di penalizzazione su cui si basa il protocollo.

\section{Transaction malleability e introduzione di SegWit}
La \textbf{transaction malleability} è una vulnerabilità strutturale introdotta nel protocollo Bitcoin dalle proprietà dell'algoritmo di firma ECDSA. Sebbene una firma garantisca che i fondi non possono essere spesi senza autorizzazione, essa non è univoca: è possibile alterare leggermente i dati della firma senza invalidarla \cite{antonopoulos2017mastering, bip141}.

Questo dettaglio crea problemi nelle operazioni in cui sono necessarie le multi-firme, quindi molte delle procedure che fanno parte del protocollo del Lightning Network, permettendo ad una delle parti generare delle firme alternative, cambiando, ad esempio, il TXID.

Di fatto è già stato detto che, quando due parti, A e B, aprono un canale stanziano dei fondi con la Funding Transaction e da quel momento in poi per eseguire qualche operazione con tali fondi è necessaria la firma di entrambi. La parte A decide di spendere parte di quei soldi, quindi viene creata una transazione TX0, che necessita la firma di entrambi, che divide i fondi in due output, il primo sono i soldi spesi, e il secondo sono i soldi che rimangono comuni nel canale, per evitare che i soldi rimangono bloccati. Per evitare di bloccare i fondi per sempre viene firmata una transazione TX1 che divide nel modo corretto i fondi del secondo output di TX0, dopodiché verrà firmata TX0 \cite{antonopoulos2017mastering}.

Viene utilizzata questa tecnica perché se firmassero solo TX0 e A sparisse, i fondi di B rimarrebbero bloccati per sempre, perché necessitano di A per essere mossi. Con TX1 che punta al TXID di TX0 B può comunque trasmettere la transazione e usare TX1 come chiave per riottenere la propria parte dei fondi \cite{poon2016lightning}.

Da qui nasce un problema fondamentale: nel protocollo originale il \textbf{TXID} è il risultato del doppio hash SHA-256 di tutti i campi della transazione, inclusi gli script di firma \textit{scriptSig}. Poiché l'algoritmo ECDSA permette di generare firme valide ma bit-a-bit differenti, e dato che le funzioni di hash modificando un solo bit generano un output totalmente diverso, una delle parti potrebbe alterare la firma di TX0 dopo che TX1 è stata creata. Se una delle due parti dopo aver firmato la transazione di uscita TX1 decidesse di modificare la propria firma di TX0 e pubblicarla sulla blockchain, il TXID di quest'ultima cambierebbe. Di conseguenza, il riferimento contenuto in TX1 diventerebbe errato, puntando ad una transazione inesistente sulla blockchain. La controparte si troverebbe quindi con una transazione di rimborso non valida, perdendo la possibilità di recuperare i fondi stanziati nel canale \cite{antonopoulos2017mastering, decker2015fast}.

Già dal 2011 gli sviluppatori sapevano come risolvere questo problema, l'idea era quella di non includere gli script di firma delle due parti negli input utilizzati per generare il TXID di una transazione, mettendo le due firme dentro una nuova struttura chiamata \textit{witness}, tale idea è chiamata \textbf{segregated witness}, o \textbf{segwit} \cite{antonopoulos2017mastering}.

Modifiche come questa creano problemi di retrocompatibilità con i blocchi vecchi, e solo nel 2015 si è trovato un approccio che rendesse il SegWit compatibile con i vecchi blocchi. Per fare ciò bisogna che i nodi nuovi, che implementano la nuova modifica, non accettino nella blockchain blocchi che i nodi vecchi senza modifica non accetterebbero. Però i nuovi nodi possono non accettare transazioni che i vecchi nodi accetterebbero, avendo così la possibilità di applicare le nuove regole di consenso \cite{antonopoulos2017mastering}.

Con la nuova struttura ogni transazione avrà due diversi ID: il TXID sarà il doppio hash SHA-256 dei dati, senza però i witness, mentre viene definito un nuovo ID, chiamato \textit{WTXID}, che è il doppio hash SHA-256 di tutti i dati inclusi i witness \cite{bip141}.

Per mantenere la retrocompatibilità e non dividere la blockchain bisogna che i vecchi nodi accettino le nuove transazioni modificate, per fare ciò SegWit lascia il campo originale in cui dovevano andare le firme vuoto. In questo modo i nodi vecchi accettano la transazione pensando che questa sia una transazione \textbf{Anyone-Can-Spend}, ossia spendibile da chiunque, mentre i nuovi nodi sanno che tale transazione non è aperta a tutti e vanno a cercare i dati dentro la struttura \textit{witness}. Se la firma nel witness risulta corretta anche loro accettano la transazione \cite{antonopoulos2017mastering}.

Questo passaggio da un modello basato su script a uno basato su \textit{witness programs} rappresenta un'importante evoluzione tecnica. Separando la logica della transazione dai dati di autenticazione, SegWit non solo risolve definitivamente il problema della \textit{transaction malleability}, eliminando le dipendenze circolari tra gli ID delle transazioni, ma aumenta anche la capacità effettiva di ogni blocco.

Garantendo l'immutabilità del TXID indipendentemente dalle firme, è finalmente possibile costruire reti di canali di pagamento istantanei, sicuri e complessi, ponendo le basi per l'architettura del Lightning Network che verrà analizzata nei capitoli successivi \cite{antonopoulos2017mastering, poon2016lightning}.

\section{Bitcoin come livello base per il Lightning Network}
In questo capitolo è stato analizzato come le proprietà di Bitcoin garantiscano un sistema sicuro e decentralizzato. Tuttavia, come discusso nel Capitolo 1, la scalabilità on-chain è molto limitata e rende impossibile utilizzare il protocollo su larga scala.

Poon e Dryja \cite{poon2016lightning} propongono quindi una soluzione di secondo livello che non sostituisce Bitcoin, ma va utilizzarlo come livello di \textbf{settlement}, sfruttando la sua blockchain. L'idea alla base è quella di non rendere necessario ai nodi di trasmettere ogni singola transazione sulla blockchain, permettendo ai nodi di scambiarsi fondi sui canali di Lightning Network tutte le volte che vogliono, utilizzando la blockchain solo per aprire il canale, chiuderlo oppure risolvere eventuali dispute.

La blockchain svolge il ruolo di un giudice imparziale in un tribunale: non è necessario rivolgersi ad essa per ogni movimento, è sufficiente avere la matematica garanzia che, in caso di disaccordo, questa possa intervenire ed eseguire il contratto corretto \cite{poon2016lightning}.

La sicurezza dei fondi nel Layer 2 è quindi \textbf{ereditata} direttamente dal Layer 1. I canali di pagamento si ancorano alla blockchain tramite transazioni multisig che bloccano fondi reali, e le transazioni off-chain sono valide solo perchè potrebbero essere trasmesse e confermate dai miner in qualsiasi momento. Con l'introduzione di SegWit, che garantisce l'immutabilità degli ID delle transazioni, questo meccanismo è reso solido \cite{antonopoulos2022masteringLN}.

Nel prossimo capitolo verrà analizzata nel dettaglio l'architettura dei canali di Lightning Network: come vengono aperti, come vengono aggiornati gli stati e come viene garantita la sicurezza senza fiducia nella controparte.

%----------------------------------------------------------------------------------------
\chapter{Architettura e funzionamento dei canali di pagamento}
%----------------------------------------------------------------------------------------
L'architettura del Lightning Network nasce con l'obiettivo di combinare la sicurezza crittografica di Bitcoin con la necessità di transazioni istantanee e scalabili. Viene proposto inizialmente nel 2015 ed implementato per la prima nel 2018, ma ad oggi si sta ancora iniziando a vedere quali sono le opportunità che tale sistema offre a Bitcoin, tra cui maggiore privacy, velocità e scalabilità \cite{antonopoulos2022masteringLN}.

Di seguito vengono delineate le caratteristiche distintive che rendono questa rete superiore ai sistemi di pagamento tradizionali e alle transazioni on-chain:
\begin{itemize}
    \item \textbf{Velocità e Finalità immediata}: a differenza di Bitcoin, dove è necessario attendere la conferma dei miner, i pagamenti su Lightning Network si concludono in pochi secondi. Una volta scambiate le firme, la transazione è considerata finale e irreversibile tra le parti.
    \item \textbf{Privacy e Risparmio di risorse}: le transazioni che avvengono off-chain rimangono tra i partecipanti del canale, non vengono trasmesse in broadcast a tutta la rete. Non dovendo essere memorizzate nella blockchain globale richiedono pochissime risorse computazionali e di archiviazione \cite{poon2016lightning}.
    \item \textbf{Utilizzo dell'asset nativo}: il Lightning Network non impiega token proprietari, ma opera direttamente con Bitcoin, garantendo che l'utente mantenga la custodia dei fondi e la sicurezza crittografica del livello base.
\end{itemize}

L'intero funzionamento si basa sulla creazione di un contratto intelligente, detto \textbf{smart contract}, che regola lo scambio di fondi tra due nodi. Nelle sezioni seguenti verrà detto come queste proprietà teoriche vengano concretizzate in operazioni crittografiche, partendo dalla creazione di un canale fino alla sua risoluzione \cite{antonopoulos2022masteringLN}.

\section{Apertura del canale}
Prima che due nodi possano aprire un canale, è necessario che stabiliscano una connessione sicura a livello di trasporto. I nodi Lightning comunicano tramite TCP/IP e utilizzano un protocollo crittografico specifico, derivato dal framework \textit{Noise Protocol}, per garantire la riservatezza e l'integrità dei dati scambiati.

Durante la fase nota come \textit{handshake}, i nodi si scambiano le chiavi pubbliche e generano una chiave di sessione effimera. Solo una volta stabilito questo tunnel cifrato, i peer possono iniziare a scambiare i messaggi definiti nel protocollo BOLT, Basis of Lightning Technology, per la gestione del canale \cite{bolt8_transport}.

Il processo di apertura di un canale di Lightning Network è avviato da uno dei due nodi, definito il \textit{funder}, che intende impegnare i propri fondi nel canale. La procedura segue uno schema preciso volto a garantire che nessuna delle due parti possa perdere i fondi, nemmeno in caso di disconnessione o malfunzionamento della controparte durante il processo \cite{antonopoulos2022masteringLN}.

Come mostrato in Figura \ref{fig:channel_opening_flow}, il protocollo prevede che il fondatore del canale invii un messaggio, chiamato \texttt{open\_channel},  alla controparte, contenente i parametri tecnici ed economici del canale. La controparte, che viene denominata \textit{fundee}, può scegliere se accettare le condizioni proposte, rispondendo con il messaggio \texttt{accept\_channel}, fornendo la propria chiave pubblica temporanea per il multisig e i propri parametri di sicurezza, oppure rifiutare. 

Nel caso in cui la controparte accettasse, il funder costruisce la \textit{Funding Transaction}. Questa transazione ha l'obiettivo di vincolare i fondi su un indirizzo \textit{Multi-Signature 2-of-2} che entrambe le parti controllano. È fondamentale che tale transazione non venga trasmessa subito sulla blockchain, il funder, infatti, crea la prima versione della \textit{Commitment Transaction}, la transazione di rimborso, che gli permette di recuperare i fondi in caso di problemi. Invia quindi la firma per la Commitment Transaction della controparte tramite il messaggio \texttt{funding\_created}. Il fundee riceve la firma, verifica la transazione e, a sua volta, invia la propria firma per la Commitment Transaction del funder tramite il messaggio \texttt{funding\_signed} \cite{bolt2_peer}.

Dopo aver ricevuto quest'ultimo messaggio, il funder ha la certezza matematica di poter recuperare i propri fondi in caso di mancata cooperazione della controparte. Solo in questo momento trasmette la \textit{Funding Transaction} alla blockchain di Bitcoin. Se la \textit{Funding Transaction} fosse stata elaborata dalla blockchain prima della creazione della \textit{Commitment Transaction} e il procedimento si fosse blocato, i fondi sarebbe andati perduti. Successivamente entrambi i nodi monitorano la blockchain e quando la Funding Transaction viene confermata, i nodi si scambiano il messaggio \texttt{funding\_locked}. Da questo istante, il canale è considerato attivo e può processare pagamenti off-chain \cite{antonopoulos2022masteringLN}.

Se una qualsiasi di queste operazioni fallisce, semplicemente la procedura viene bloccata e il canale non viene creato. Si noti che i canali possono lavorare in parallelo perché ognuno di essi è identificabile tramite il proprio \textbf{channel\_id} \cite{bolt2_peer}.

Il messaggio \textbf{open\_chanel} contiene diversi parametri utili a conservare le informazioni e le prospettive che il fondatore del canale ha, e che la controparte può accettare o declinare. Tra i più rilevanti figurano:
    \begin{itemize}
        \item \texttt{funding\_satoshis}: l'importo totale che il funder depositerà nel canale.
        \item \texttt{push\_msat}: un importo opzionale che il funder può regalare immediatamente alla controparte, solitamente è zero.
        \item \texttt{to\_self\_delay}: il ritardo di sicurezza, espresso in blocchi, richiesto in caso di chiusura unilaterale del canale.
        \item \texttt{channel\_reserve\_satoshis}: l'importo minimo che ogni parte deve mantenere nel canale per disincentivare comportamenti scorretti \cite{bolt2_peer}.
    \end{itemize}

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/openChanel.png}
    \caption[Flusso di apertura di un canale Lightning]{Diagramma di sequenza del protocollo di apertura di un canale. I messaggi vengono scambiati peer-to-peer per negoziare i parametri e scambiare le firme prima della trasmissione on-chain. Fonte: rielaborazione da Antonopoulos \cite{antonopoulos2022masteringLN}.}
    \label{fig:channel_opening_flow}
\end{figure}

\section{Aggiornamento dello stato e meccanismi di sicurezza}
La possibilità di aggiornare lo stato del canale infinite volte, riorganizzando i fondi senza dover interagire con la blockchain, avendo sempre la matematica certezza di poter evitare eventuali truffe, è l'innovazione principale su cui si basa il Lightning Netowork, e che distingue questo meccanismo dai canali di pagamento tradizionali.

Un aggiornamento non comporta lo spostamento di nuovi fondi all'interno del canale, ma consiste in una ridefinizione del bilancio dei fondi inizialmente bloccati nella \textit{Funding Transaction}. I nodi concordano una nuova suddivisione del saldo, generando di conseguenza una nuova coppia di \textit{Commitment Transactions} valide e invalidando lo stato precedente \cite{antonopoulos2022masteringLN}.

Nella Figura \ref{fig:channel_update_flow} è mostrato il diagramma di sequenza per la modifica dello stato: i nodi si scambiano le firme per il nuovo impegno e  la chiave di revoca per annullare l'impegno vecchio.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/updateChannel.png}
    \caption[Diagramma di aggiornamento dello stato]{Diagramma di sequenza del protocollo di aggiornamento dello stato. Lo scambio dei messaggi garantisce che entrambe le parti possiedano una nuova transazione di impegno valida e abbiano revocato la precedente. Fonte: rielaborazione da Antonopoulos \cite{antonopoulos2022masteringLN}.}
    \label{fig:channel_update_flow}
\end{figure}

Di seguito viene analizzata la struttura delle transazioni che si scambiano le due parti e verranno analizzati i messaggi in Figura \ref{fig:channel_update_flow}

\subsection{Transazioni asimmetriche}
Durante l'aggiornamento dello stato di un canale, i nodi partecipanti non firmano la medesima transazione, infatti ne vengono generate due versioni differenti, ma speculari. La versione posseduta dal nodo A invia immediatamente i fondi destinati a B, ma blocca con un \textit{timelock} i fondi destinati ad A. Al contrario, la versione posseduta da B blocca i fondi ad esso destinati, ma rende subito disponibili quelli per A \cite{antonopoulos2022masteringLN}.

Tale asimmetria intenzionale serve a disincentivare la chiusura unilaterale del canale, costringendo ad attendere un periodo predefinito di tempo a chi pubblica la transazione, mentre la controparte riceve i propri fondi subito. Questo meccanismo offre alla parte passiva una finestra temporale per poter rilevare un eventuale tentativo di frode e reagire \cite{poon2016lightning}.

Il messaggio \texttt{commitment\_signed}, che nella Figura \ref{fig:channel_update_flow} viene inviato prima da A poi da B, contiene la firma che una parte appone sulla versione della \textit{Commitment Transaction} che la controparte detiene, validando quindi il nuovo bilancio dei fondi \cite{bolt2_peer}.

\subsection{Revoca dello stato precedente (RSMC)}
Come già esposto, è fondamentale in questa procedura garantire che i vecchi stati non possano più essere utilizzati. Una volta che il nuovo stato è stato firmato viene sfruttato un meccanismo chiamato \textbf{Revocable Sequence Maturity Contract}, che permette una invalidazione crittografica degli stati precedenti \cite{poon2016lightning}.

Come da Figura \ref{fig:channel_update_flow}, il nodo che ha ricevuto la nuova firma risponde con il messaggio \texttt{revoke\_and\_ack}. Questo messaggio contiene la \textit{revocation key}, ossia la chiave di revoca, un segreto crittografico fondamentale relativo allo stato appena passato \cite{bolt2_peer}.

Una volta avvenuto questo scambio, se, per esempio, il nodo A decidesse di pubblicare una vecchia transazione revocata sulla blockchain, la controparte B potrebbe utilizzare la chiave di revoca che gli è stata inviata per penalizzare A secondo i termini definiti nello \textbf{smart contract} del protocollo. Tipicamente la vittima del tentativo di frode preleva immediatamente tutti i fondi impegnati nel canale, confiscando anche quelli che sarebbero dovuti spettare al truffatore, attraverso una cosiddetta \textit{Penalty Transaction} o \textit{Justice Transaction} \cite{antonopoulos2022masteringLN}.

\section{Chiusura del canale}
La chiusura rappresenta la fase finale del ciclo di vita di un canale. Come visto precedentemente, la chiusura unilaterale è disincentivata attraverso l'utilizzo dei \textit{timelock}. Esiste infatti un'altra modalità, ritenuta migliore, per chiudere il canale: la modalità cooperativa. Essa infatti permette alle due parti di chiudere il canale cooperando e permettendo loro di ottenere immediatamente i propri fondi, senza dover aspettare \cite{antonopoulos2022masteringLN}.

Di seguito verranno analizzate entrambe le modalità di chiusura.

\subsection{Chiusura cooperativa: Mutual Close}
La \textbf{chiusura cooperativa}, detta \textbf{Mutual Close}, è la modalità di chiusura che il protocollo favorisce, in quanto immediata, economica e priva di vincoli temporali sui fondi \cite{poon2016lightning}.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/closing.png}
    \caption[Diagramma di chiusura cooperativa]{Diagramma di sequenza della chiusura cooperativa (Mutual Close). Le parti negoziano le commissioni e si scambiano le firme per una transazione finale di chiusura priva di timelock. Fonte: rielaborazione da Antonopoulos \cite{antonopoulos2022masteringLN}.}
    \label{fig:mutual_close}
\end{figure}

In Figura \ref{fig:mutual_close} viene mostrato lo scambio di messaggi che avviene tra i due nodi per chiudere il canale in comune accordo. Nello schema rappresentato è il nodo A a voler iniziare la procedura di chiusura. Esso infatti inizia inviando un messaggio di \texttt{shutdown} alla controparte B, contenente il riferimento tramite ID al canale da chiudere e l'indirizzo Bitcoin del wallet al quale vorrebbe che i fondi venissero inviati.

B risponde inviando lo stesso messaggio a sua volta, concordando con la volontà di chiusura di A e specificando il proprio wallet.

Una volta scambiate queste informazioni, le due parti sono pronte per generare la transazione finale che chiude il canale e divide i fondi nella maniera corretta \cite{antonopoulos2022masteringLN}.

Infatti, il \textit{funder} del canale, in questo caso A, invia alla controparte un messaggio denominato \texttt{closing\_signed}, in cui specifica in \textit{satoshi} la \textit{fee} (una sorta di tassa) da pagare per pubblicare la transazione sulla blockchain, e inserisce la propria firma per la multisig 2-of-2 \cite{bolt2_peer}.

Quando B riceve questo messaggio, deve inviarne uno uguale a sua volta, in cui confermare l'importo della \textit{fee}, inserendo lo stesso valore scelto da A e apponendo al messaggio la propria firma, oppure può proporre un nuovo valore per la \textit{fee} semplicemente inviando un valore diverso.

La negoziazione sulla \textit{fee} prosegue fino a che A non riceve indietro da B un messaggio firmato con lo stesso valore in \textit{satoshi}. A questo punto la procedura è finita e il \textit{funder} può pubblicare sulla blockchain la \textbf{Closing Transaction} \cite{antonopoulos2022masteringLN}.

Si noti che questa \textbf{Closing Transaction} è simile all'ultima \textbf{Commitment Transaction} su cui i due nodi erano d'accordo. La differenza sostanziale risiede nel fatto che durante la procedura le due parti collaborano per creare tale transazione, che è uguale per entrambi e che non necessita più dell'utilizzo dei \textit{timelock} per risolvere eventuali frodi \cite{antonopoulos2022masteringLN}.

Per aumentare la sicurezza, il protocollo utilizza un pratica detta \textbf{Up-front Shutdown Script}, che permette di definire l'indirizzo di chiusura già al momento dell'apertura del canale, nei messaggi \texttt{open\_channel} o \texttt{accept\_channel}. Grazie a questa pratica, se un attaccante dovesse compromettere uno dei nodi, non potrebbe in alcun modo chiudere il canale e inviare i fondi a un indirizzo diverso da quello su cui i nodi si erano già accordati. Se l'indirizzo non corrisponde, il protocollo impone alla controparte onesta di rifiutare la chiusura cooperativa \cite{antonopoulos2022masteringLN}.

\subsection{Chiusura unilaterale: Force Close}
La \textbf{chiusura unilaterale}, o \textbf{Force Close}, si verifica quando un nodo decide di chiudere il canale, senza prima avvertire la controparte, pubblicando l'ultimo stato di cui ha possesso sulla blockchain. Questo scenario si verifica nel caso in cui la controparte risultasse offline, smettesse di rispondere, o iniziasse a comportarsi in modo malevolo.

In questa variante, il nodo che forza la chiusura pubblica l'ultima \textbf{Commitment Transaction} valida in suo possesso. Come già discusso nella Sezione 4.2, questa transazione è asimmetrica e comporta delle penalizzazioni per chi la trasmette \cite{poon2016lightning}: infatti i fondi destinati a chi ha avviato la chiusura rimangono bloccati per un periodo definito dal parametro \texttt{to\_self\_delay}, solitamente 144 blocchi. Inoltre le commissioni di mining, ossia le \textit{fee}, sono spesso più alte rispetto alla chiusura presentata precedentemente, perché la transazione risulta più complessa ed occupa più spazio in memoria \cite{antonopoulos2022masteringLN}.

Va infine notato che la chiusura unilaterale è proprio il modo attraverso il quale si può tentare una frode. Se un nodo malevolo non pubblicasse l'ultimo stato valido, ma uno stato precedente con un bilancio per lui più remunerativo, la controparte onesta potrebbe reagire entro la scadenza del \texttt{to\_self\_delay}. In tal caso, la chiusura forzata si trasformerebbe in una \textit{Penalty Transaction}, permettendo alla vittima di confiscare l'intera quantità dei fondi impegnati nel canale grazie al meccanismo di revoca \cite{antonopoulos2022masteringLN}.

\section{Gestione dei nodi offline e ruolo delle watchtower}
Uno dei requisiti più stringenti del Lightning Network è la necessità che i componenti della rete partecipino attivamente. Nel Lightning Network è fondamentale che un nodo monitori costantemente la blockchain, a differenza dei wallet Bitcoin tradizionali, che possono rimanere offline per lunghi periodi senza rischi per la sicurezza dei fondi. Questo vincolo è noto come \textit{requisito di liveness} \cite{poon2016lightning}.

\subsection{Il problema della liveness}
Come analizzato nella Sezione 4.2, la sicurezza dei canali di pagamento si basa interamente sulla minaccia di una penalità. Se un nodo disonesto tenta di chiudere il canale pubblicando uno stato precedente e revocato, la vittima ha a disposizione una finestra temporale limitata, definita dal parametro \texttt{to\_self\_delay}, per reagire.

Nell'ipotesi in cui la vittima si trovasse offline a causa di guasti tecnici, problemi di connessione o attacchi mirati, come può essere un attacco DDoS, e non rilevasse la frode entro la scadenza del \textit{timelock}, il vecchio stato pubblicato dal truffatore sulla blockchain verrà confermato, permettendogli di rubare i fondi. Per colpa di questa vulnerabilità risulta rischioso gestire un nodo Lightning su dispositivi mobili o computer non sempre connessi alla rete \cite{antonopoulos2022masteringLN}.

\subsection{Watchtower: outsourcing della sicurezza}
Per abbassare questo rischio senza costringere ogni utente a mantenere i propri server costantemente attivi, è stato introdotto il concetto di torre di guardia, a cui ci si riferisce con il termine \textbf{Watchtower}. Una Watchtower è un servizio di terze parti che offre la possibilità ad un nodo di delegare il compito di monitorare la blockchain, intervenendo in caso di tentata frode.

Il protocollo, definito inizialmente nel paper "Pisa" da McCorry, permette di effettuare questo \textit{outsourcing} preservando completamente la privacy dell'utente. Infatti, a meno che non si verifichi una frode, non è necessario che la torre sia a conoscenza dell'identità delle parti che hanno definito lo \textit{smart contract}, tanto meno della quantità di fondi impiegati nel canale e del contenuto delle transazioni \cite{mccorry2018pisa}.

Il funzionamento si basa sull'invio di dati parziali e cifrati. Ogni volta che lo stato del canale viene aggiornato, il client invia alla Watchtower un pacchetto dati composto da due elementi \cite{antonopoulos2022masteringLN}:
\begin{itemize}
\item \textbf{Hint}: i primi 16 byte del TXID della transazione di impegno. Con questo la torre scansiona la blockchain e riconosce se una specifica transazione viene pubblicata, senza però rivelare l'intera transazione a priori.
\item \textbf{Encrypted Blob}: payload cifrato che contiene la firma della \textit{Justice Transaction} e la chiave di revoca necessaria per spostare i fondi.
\end{itemize}

La torre memorizza questi dati in un database ma non può decifrare il \textit{blob} finché non trova una corrispondenza con l'\textit{hint} sulla blockchain.
Se la torre rileva che la controparte ha pubblicato uno stato revocato, può utilizzare i dati della transazione malevola stessa per derivare la chiave di decifratura. A quel punto, la torre decifra il blob, costruisce la transazione di punizione e la trasmette alla rete, inviando i fondi al wallet definito dall'utente offline e trattenendo una piccola parte dell'importo come ricompensa per il lavoro svolto\cite{mccorry2018pisa}.

Grazie a questo meccanismo, la sicurezza del canale è garantita anche se l'utente è offline, disincentivando i tentativi di frode poiché l'attaccante non può sapere se la vittima sta utilizzando una o più Watchtower per sorvegliare il canale.

%----------------------------------------------------------------------------------------
\chapter{Dal singolo canale di pagamento alla rete Lightning}
%----------------------------------------------------------------------------------------
Nei capitoli precedenti è stato discusso il funzionamento del protocollo originale di Bitcoin, analizzandone le principali problematiche a livello di scalabilità, ed è stato studiato il protocollo Lightning Network come soluzione. Sono poi stati visti i dettagli tecnici che permettono a tale protocollo di funzionare, ed è stato visto come rendere sicuro ed affidabile un canale di pagamento tra due nodi.

Per rendere Bitcoin una moneta utilizzabile a livello globale però, non è sufficiente un solo collegamento tra due nodi, così come non è sostenibile che ogni nodo apra un canale con qualsiasi nodo con cui voglia scambiare denaro. Creare tanti canali fa aumentare i costi on-chain, perchè aumenta il numero di \textit{fee} pagate durante la chiusura, e soprattutto costringi i nodi a bloccare gran parte dei propri fondi \cite{poon2016lightning}.

Diventa quindi fondamentale creare una rete di nodi, che li renda connessi tra loro anche senza collegamento diretto. Se il nodo A volesse pagare il nodo C, sapendo che il nodo B è connesso con entrambi, potrebbe utilizzare proprio questo nodo come intermediario per svolgere la sua operazione.

In questo capitolo verranno quindi analizzati il protocollo di routing e gli HTLC, contratti che rendono possibile pagare nodi senza collegamento diretto, concentrandosi su come gli HTLC permettano di instradare pagamenti attraverso nodi che fungono da intermediari in modo \textit{trustless}, senza che essi possano rubare i fondi.

\section{Pagamenti attraverso nodi intermedi}
Gli \textbf{HTLC}, ossia \textbf{Hashed Timelock Contract}, sono i contratti utilizzati per permettere a nodi non direttamente collegati di effettuare dei pagamenti utilizzando nodi intermedi collegati ad entrambi \cite{poon2016lightning}.

Il problema che questi contratti devono risolvere in realtà non è solo strettamente collegato alle monete digitali, ma anche alle valute fisiche. Le dinamiche da evitare, che possono accadere utilizzando degli intermediari per il pagamento, sono due: per andarle ad analizzare si suppone di avere tre nodi $A$, $B$ e $C$, e che $A$ e $C$ siano entrambi collegati con B ma non abbiano modo di comunicare tra loro direttamente. 
\begin{itemize}
    \item $A$ ha necessità di dare del denaro a $C$ e quindi lo dà a $B$ sperando che poi questo lo dia a $C$. $B$ potrebbe prendere i soldi e scappare.
    \item Se invece $B$ anticipasse i soldi a $C$, $A$ avrebbe estinto il suo debito con $C$ e potrebbe non rimborsare mai $B$.
\end{itemize}

È necessario un protocollo che garantisca l'\textbf{atomicità} di queste operazioni. Un \textbf{protocollo di scambio atomico} per essere tale deve garantire queste tre condizioni \cite{herlihy2018atomic}:
\begin{enumerate}
    \item se tutti le parti coinvolte si attengono al protocollo e svolgono le adeguatamente i loro compiti allora verranno eseguite tutte le operazioni.
    \item nel caso in cui qualche malintenzionato dovesse non rispettare le regole del protocollo allora sarà lui ad avere la peggio.
    \item non deve incentivare coalizione tra parti per deviare il protocollo.
\end{enumerate}

Per soddisfare tali requisiti, il Lightning Network utilizza appunto un \textbf{Hashed Timelock Contract} sfruttando le \textit{funzioni di hash}. In questa tipologia di contratti viene memorizzata la coppia $(h,t)$, che vincola i fondi secondo due clausole condizionali:
\begin{enumerate}
    \item se colui che deve ricevere il pagamento riesce a fornire il segreto $s$ tale che $h = H(s)$ prima che scada il tempo $t$, allora il contratto viene eseguito e i fondi vengono trasferiti. Non c'è più alcun modo per il mittente di ritirare i propri fondi.
    \item se il segreto $s$ non viene fornito entro il tempo $t$, i fondi vengono ridati al mittente tramite una \textit{transazione di rimborso}.
\end{enumerate}

Sebbene esistano diverse varianti di questo meccanismo \cite{herlihy2018atomic}, nel Lightning Network è il destinatario finale ad avviare il processo generando il segreto $s$, detto anche  \textit{pre-image}, calcolandone $h = H(s)$. Al mittente viene poi comunicato $h$ e utilizzato per bloccare i fondi lungo tutta la catena di nodi attraversati \cite{poon2016lightning}.

Di seguito vengono trattare le due fasi in cui si svolge il pagamento.

\subsection{Locking dei fondi}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/htlcAdd.png}
    \caption[Diagramma di aggiunta HTLC]{Fase di Locking: Il nodo A invia un messaggio \texttt{update\_add\_htlc} per offrire un contratto condizionale a B. Seguono gli scambi di firme e revoche per impegnare il nuovo stato. Fonte: rielaborazione da Antonopoulos \cite{antonopoulos2022masteringLN}.}
    \label{fig:htlc_add}
\end{figure}

Nella prima fase, detta \textit{Locking}, i contratti HTLC vengono propagati dal mittente verso il destinatario, aggiungendo output condizionale al canale già esistente. Di fatto, tornando all'esempio in cui $A$ deve pagare $C$, sarà $A$ che genera un HTLC a $B$, e di conseguenza $B$ che genera un HTLC a $C$. Come osservabile nella Figura \ref{fig:htlc_add}, l'inserimento del contratto al canale viene attuata con il messaggio \texttt{update\_add\_htlc}. Tale messaggio è composto da diversi campi, tra cui i più importanti sono \cite{antonopoulos2022masteringLN}:
\begin{itemize}
    \item \textbf{id}: ID del contratto appena aggiunto.
    \item \textbf{amount\_msat}: quantità di satoshi vincolata.
    \item \textbf{payment\_hash}: l'hash del segreto, ossia $H$.
    \item \textbf{cltv\_expiry}: il tempo dopo il quale il mittente viene rimborsato.
    \item \textbf{onion\_routing\_packet}: la onion-encrypted-route, che indica il prossimo nodo della catena, questo sistema verrà analizzato nella Sezione successiva.
\end{itemize}

\subsection{Unlocking dei fondi}
\begin{figure}[h!]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/htlcFinish.png}
    \caption[Diagramma di risoluzione HTLC]{Fase di Unlocking: Il nodo B, dopo aver ricevuto la pre-image, invia \texttt{update\_fulfill\_htlc} ad A per sbloccare i fondi. Anche qui segue lo scambio di firme per consolidare il saldo. Fonte: rielaborazione da Antonopoulos \cite{antonopoulos2022masteringLN}.}
    \label{fig:htlc_fulfill}
\end{figure}
La seconda fase, invece, è l'\textit{Unlocking dei fondi}. Se i contratti vengono propagati dal mittente al destinatario, i segreti $s$ seguono il percorso inverso. Quando $C$, ossia il destinatario finale del pagamento, riceve il contratto da $B$, è costratto a mostrargli il segreto $s$ per poter sbloccare i fondi. A questo punto $B$ è anch'esso entrato in possesso del segreto e quindi può rivelarlo ad $A$ per sbloccare i fondi vincolati nel loro contratto.
Come osservabile in Figura \ref{fig:htlc_fulfill}, per trasmettere il $s$ e finalizzare il pagamento viene utilizzato il messaggio \texttt{update\_fulfill\_htlc}. Esso è composto da tre campi \cite{antonopoulos2022masteringLN}: 
\begin{itemize}
    \item \textbf{channel\_id}: ID del canale di Lightning.
    \item \textbf{id}: ID del contratto HTLC in questione.
    \item \textbf{payment\_preimage}: il segreto che sblocca i fondi.
\end{itemize}

È fondamentale notare che quest'ultimo passaggio non prova esclusivamente la conoscenza del segreto, ma serve anche a modificare lo stato del canale. Il messaggio rimuove il vincolo condizionale, imposto dall'HTLC, dalla \textit{Commitment Transaction} e accredita l'importo nel saldo principale del ricevente. Solo dopo il successivo scambio di firme, coi messaggi \texttt{commitment\_signed} e \texttt{revoke\_and\_ack}, il pagamento è considerato definitivo e il vincolo eliminato.

\subsection{Vincoli temporali e sicurezza}
Come trattato nelle Sezioni precedenti, i contratti HTLC sono strettamente legati al tempo. Quest'ultimo, infatti, è un elemento fondamentale per la sicurezza di questo meccanismo e senza di esso si andrebbe incontro al rischio che, nel caso in cui non si porti a termine l'operazione, i nodi si ritrovino con i fondi vincolati bloccati per sempre.

È infatti molto importante l'ordine in cui i contratti vengono stipulati e, soprattutto, l'ordine in cui scadono i timelock. La scadenza del timelock di un contratto in entrata deve essere sempre superiore alla scadenza del timelock di un contratto in uscita, e questo deve ripetersi per tutta la catena di HTLC che si verrà a creare \cite{herlihy2018atomic}.

Di fatti, se il contratto tra $A$ e $B$ scadesse nello stesso esatto momento di quello tra $B$ e $C$, nel caso in cui $C$ rivelasse all'ultimo istante il segreto a $B$, il primo riuscirebbe a sbloccare il proprio denaro, ma $B$ non avrebbe abbastanza tempo per rivelare il segreto ad $A$ e ottenere a sua volta i fondi che gli spettano.

Se queste regole vengono rispettate e tutti i partecipanti alla catena collaborano correttamente, si ha la certezza che ogni operazione venga portata a termine e non accada nulla di spiacevole. Se invece per un qualsiasi motivo un nodo smettesse di collaborare, sarò proprio esso ad ottenere la conseguenza peggiore. Infatti se, in una situazione ideale in cui i timelock sono stati utilizzati nel modo giusto, $B$ decidesse di smettere di collaborare dopo aver generato il contratto con $C$, quest'ultimo otterrebbe i propri fondi con il segreto $s$, $A$ verrebbe rimborsato allo scadere del timelock, e $B$ rimarrebbe l'unico nodo ad aver perso i fondi \cite{herlihy2018atomic}.

\section{Routing dei pagamenti e diffusione delle informazioni}
Come anticipato, il Lightning Network utilizza un protocollo di routing per permettere ai pagamenti di arrivare a destinazione passando attraverso altri nodi appartenenti alla rete. Per sapere come instradarli è necessario che ogni nodo abbia una propria mappa della rete e sia a conoscenza dei nodi e dei canali attraversabili \cite{antonopoulos2022masteringLN}.

\subsection{Protocollo di Gossip}
Per fare ciò viene utilizzato un \textbf{protocollo di gossip} che permette di scoprire i collegamenti e i nodi della rete attraverso due messaggi: il \texttt{node\_announcement} e lo \texttt{channel\_announcement}.

Attraverso il messaggio \texttt{node\_announcement} i nodi si annunciano alla rete inviando in broadcast ID, host e port, in modo tale da permettere agli altri di stabilire delle connessioni con lui. Ogni nodo può inviare più messaggi di questa tipologia per comunicare eventuali aggiornamenti delle informazioni.

Il messaggio \texttt{channel\_announcement}, invece, comunica alla rete la creazione di un canale tra due nodi e permette implicitamente ad ogni nodo di generarsi una propria mappa della topologia della rete, così facendo essi saranno in grado di generare il percorso di instradamento per i pagamenti \cite{bolt7_routing}.

L'annuncio di un canale è un meccanismo complicato perché fondamentale per il routing. Infatti se la rete venisse inondata di annunci di canali falsi sarebbe impossibile per i nodi capire quale percorso fare seguire ai propri pagamenti. A differenza del messaggio per annunciare i nodi, lo \texttt{channel\_announcement} per un determinato canale può essere propagato solamente una volta. Esiste poi un messaggio specifico per l'aggiornamento delle informazioni, ossia lo \texttt{channel\_update}, che svolge anche un ruolo fondamentale nella verifica dell'effettiva esistenza del canale annunciato.

Infatti, per provare l'esistenza di un canale, è necessario:
\begin{enumerate}
    \item dimostrare l'esistenza di una \textit{Funding Transaction} nella blockchain tra i due nodi.
    \item il nodo 1 e il nodo 2 devono condividere le firme digitali in grado di dimostrare il possedimento delle chiavi private dei bitcoin bloccati nella transazione e le chiavi private dei nodi che annunciano il canale.
\end{enumerate}

Per dimostrare le ultime due condizioni, i nodi inviano le altre informazioni tramite il messaggio \texttt{channel\_update}. Di conseguenza per dimostrare l'esistenza di un canale è necessario uno e un solo messaggio \texttt{channel\_announcement} e due messaggi \texttt{channel\_update}, uno per nodo \cite{bolt7_routing}.

\subsection{Instradamento e selezione del percorso}
Prima di trattare la selezione del percorso, detta \textbf{pathfinding} è necessario fare una precisazione: il \textit{pathfinding} e il \textit{routing} sono due concetti separati.
Il primo si occupa di scegliere il percorso in grado di connettere il mittente con il destinatario, esaminando la mappa che il mittente si è generato. Il secondo, invece, si riferisce alla seria di interazione che avvengono durante il percorso predeterminato da un nodo $A$ ad un nodo $B$ \cite{antonopoulos2022masteringLN}.

A differenza dei protocolli di routing classici, come il protocollo IP, dove ogni router decide autonomamente qual è il passo successivo da compiere, il Lightning Network adotta un approccio basato sul \textbf{Source Routing}.

In questo modello è il mittente a calcolare l'intero percorso, in base alla mappa della topologia della rete che si è costruito grazie al \textit{protocollo di gossip}, prima di inviare il primo pacchetto.
Tale architettura risolve il problema della privacy, impedendo ai nodi intermedi di conoscere l'intera rotta e il mittente e destinatario del pagamento \cite{antonopoulos2022masteringLN}.

Per scegliere il percorso migliore, il mittente trasforma la mappa in un grafo pesato, ed applica i classici algoritmi di ricerca del cammino minimo, come ad esempio \textit{Dijkstra}. Gli aspetti che vengono valutati per trovare il percorso ottimale sono i seguenti:
\begin{itemize}
\item \textbf{Fees:} Ogni canale prende una tariffa base e una percentuale sull'importo transato. Dunque vengono preferiti i percorsi più economici.
\item \textbf{Ritardo temporale:} Ogni salto, detto \textbf{hop}, allunga i tempi di consegna. Scegliere percorsi troppo lunghi comporta tempi di attesa maggiori.
\item \textbf{Capacità del canale:} Vengono esclusi a priori i canali la cui capacità totale, che è pubblicata sulla blockchain, è inferiore all'importo del pagamento.
\end{itemize}

Quest'ultimo punto introduce la sfida dell'\textbf{incertezza della liquidità}, che il Lightning Network deve risolvere. Come detto, la capacità totale di un canale è un dato pubblico, ma la distribuzione attuale dei fondi al suo interno è un'informazione privata. Il mittente, quando calcola la rotta, non ha la certezza che un nodo abbia abbastanza liquidità dalla sua parte per inoltrare il pagamento. Questo rende \textit{probabilistico} il processo di pathfinding. La probabilità di successo di un percorso viene stimata, e nel caso in cui esso fallisca, il mittente riceve un messaggio d'errore e calcola un percorso alternativo, evitando il nodo che ha generato il problema \cite{antonopoulos2022masteringLN}.

\subsection{Onion Routing e Sicurezza}
Una volta che è stato calcolato il percorso ottimale per il routing, il mittente deve costruire il pacchetto di pagamento in modo tale da garantire la privacy e l'integrità dei dati. Tale pacchetto non può essere trasmesso in chiaro durante il percorso, perché ogni nodo intermedio verrebbe a conoscenza dell'identità del mittente e del beneficiario e dell'importo totale del pagamento, così facendo verrebbe compromessa la privacy e la sicurezza della rete.

Il Lightning Network, per risolvere questo problema, implementa un protocollo basato sulla costruzione di pacchetti \textit{Sphinx}. Originariamente proposto da Danezis e Goldberg nel 2009 come formato compatto e sicuro per reti di mixaggio \cite{danezis2009sphinx}, è stato adattato come protocollo per il routing del Lightning Network e chiamato \textbf{Onion Routing} \cite{bolt4_onion}.

Alla base di \textit{Sphinx} c'è il concetto di crittografia a strati. I dati di routing vengono avvolti progressivamente, iniziando dall'ultimo nodo del percorso fino ad arrivare al primo. Ogni nodo intermedio utilizza la propria chiave privata per decifrare esclusivamente lo strato più esterno a lui destinato, senza poter sbirciare gli altri strati. In questo modo ad ogni nodo vengono rivelate solamente le informazioni strettamente necessarie per quel salto. Tali informazioni sono:
\begin{itemize}
    \item L'identità del nodo successivo a cui inoltrare il pacchetto, ossia il \textit{Next Hop}.
    \item La scadenza del timelock e l'importo da inoltrare.
    \item Un codice di autenticazione, utile per verificare che il pacchetto non sia stato manomesso.
\end{itemize}

Una proprietà fondamentale, che permette ai pacchetti Sphinx di mantenere privacy e sicurezza, è che hanno una \textbf{dimensione fissa}. Ad ogni passaggio, il pacchetto mantiene la sua lunghezza in byte costante. In questo modo, un osservatore esterno oppure un nodo malevolo, non è in grado di dedurre la posizione del nodo corrente all'interno del percorso, o non può calcolare la lunghezza totale del tragitto basandosi sulla dimensione dei dati \cite{antonopoulos2022masteringLN}.
Ogni nodo conosce quindi solo il proprio predecessore e il proprio successore, ignorando completamente l'origine e la destinazione finale del pagamento.

\subsubsection{Fairness Protocol}
Come detto al Capitolo 1, l'innovazione principale portata da Bitcoin è l'utilizzo di primitive crittografiche per sostituire la fiducia negli intermediari con la fiducia in un protocollo verificabile. Il Lightning Network estende proprio questo concetto \cite{antonopoulos2022masteringLN}.

Le proprietà garantite da questo protocollo sono tre:
\begin{enumerate}
    \item \textbf{Operazioni Trustless:} i nodi che fanno parte del percorso di un pagamento non devono fidarsi l'uno dell'altro. La crittografia e il protocollo proteggono i fondi da furti o appropriazioni indebite.
    \item \textbf{Atomicità:} il pagamento è un'operazione atomica, o vengono eseguiti tutti i passaggi ed i fondi raggiungono il destinatario, oppure fallisce completamente e tutti i fondi vengono rimborsati ai rispettivi proprietari. Non esiste alcuno stato intermedio.
    \item \textbf{Sicurezza Multi-hop:} La sicurezza del sistema non degrada con l'aumentare della lunghezza del percorso.
\end{enumerate}

L'Onion Routing assicura che il contenuto dei pagamenti e il percorso rimangano segreti durante il transito, ma il fatto che il grafo dei canali e le dinamiche di routing siano pubbliche espongono la rete ad altre tipologie di analisi. Nella prossima sezione verranno esaminati i limiti della privacy.

\section{Aspetti di privacy nel Lightning Network}
In questa sezione viene analizzato come informazioni apparentemente innocue, necessarie però per il corretto funzionamento del routing, possano essere sfruttate per dedurre dati sensibili sui partecipanti.

\subsection{Analisi della topologia e correlazione Cross-Layer}
Come detto precedentemente, il Lightning Network è una soluzione di secondo livello, che si basa sul protocollo base di Bitcoin, questa soluzione non potrebbe esistere se non avesse nulla su cui appoggiarsi. Questo però crea una superficie di attacco, detta \textit{Cross-Layer De-Anonymization}. È noto che per creare un canale sia necessaria una \textit{Funding Transaction} sulla blockchain. Analizzando la blockchain, un osservatore potrebbe identificare quale UTXO ha finanziato il canale e risalire al wallet on-chain proprietario del nodo \cite{antonopoulos2022masteringLN}.

In aggiunta, il protocollo di gossip richiede che i nodi annuncino chiaramente il proprio indirizzo IP per essere raggiungibili e la propria chiave privata. Queste due semplici infomazioni, unite ad uno studio della storia delle transazioni nel nodo in questione presenti sulla blockchain, riduce drasticamente l'anonimato rispetto all'utilizzo di Bitcoin on-chain. Infatti nel protocollo originale gli indirizzi possono essere generati a ogni transazione e quindi non rimanere sempre legati ad un determinato nodo.

\subsection{Balance Probing}
Esiste una tecnica, note come \textbf{Channel Probing}, che sfrutta il meccanismo di gestione degli errori del protocollo per dedurre i saldi attuali di due nodi in un canale. Questa è una delle vulnerabilità più discusse, perché l'esatta distribuzione dei fondi all'interno di un canale in un determinato istante è un'informazione che dovrebbe rimanere privata tra le due parti.

Il principio di questa tecnica, formalizzata in \cite{herrera2019difficulty}, si basa sull'invio di finti pagamenti che non possono essere finalizzati, ma che, una volta elaborati, generano messaggi di errore informativi.

Se un nodo malevolo $M$ volesse conoscere il saldo del canale tra $A$ e $B$, deve dapprima generare un canale che lo connetta con $A$, dopodiché creerà un finto pagamento con un $H$ casuale, di cui nessuno conosce il segreto, e con un importo $k$. $A$ verrà utilizzato come non intermedio per arrivare a $B$ ed il pagamento potrà arrivare a destinazione, oppure fallire durante il percorso. I entrambi i casi la rete restituirà un messaggio di errore, ed in base ad esso è possibile ottenere informazioni sui saldi attuali. Esistono due scenari principali:
\begin{enumerate}
    \item \textbf{Unknown Payment Hash:} in questo caso il pagamento finto è arrivato a destinazione, quindi $A$ ha fondi sufficienti per inoltrare $k$ a $B$, il pagamento raggiunge $B$, ma dato che $H$ è casuale, $B$ lo rifiuta con tale errore. Si può quindi dedurre che il saldo di $A$ è $\ge k$.
    \item \textbf{Temporary Channel Failure:} il pagamento non è arrivato a destinazione, quindi $A$ non ha fondi sufficienti e restituisce un errore di liquidità insufficiente. L'attaccante dunque deduce che il saldo di $A$ è $< k$.
\end{enumerate}

Aggiustando l'import $k$ secondo i risultati ottenuti e ripetendo la procedura, seguendo un algoritmo di \textbf{ricerca binaria}, il nodo malevolo $M$ può determinare il saldo esatto del canale al singolo satoshi in pochi secondi.

Dato che i pagamenti falliti non comportano il pagamento di alcuna \textit{fee}, questa tecnica è estremamente efficace ed economica \cite{herrera2019difficulty}.

\subsection{Analisi temporale del transito}
Per quanto il sistema \textbf{Onion Routing} sia in grado di proteggere e mascherare i vari pacchetti, non è in grado di nascondere il tempo di transito degli stessi. Sebbene i pacchetti \textit{Sphinx} siano cifrati ed appaiano diversi a ogni salto, la tempistica del loro passaggio li può rendere riconoscibili.

Questa vulnerabilità espone la rete ad attacchi di \textbf{correlazione temporale}. All'interno della rete possono esserci grandi entità che controllano più nodi. Supponendo che una di esse controlli due nodi distanti appartenenti ad un percorso di pagamento, questa potrebbe individuare il mittente e il destinatario di un pagamento semplicemente osservando i tempi di ingresso e uscita di pacchetti.
Si consideri, ad esempio, il percorso $A \rightarrow M_1 \rightarrow B \rightarrow C \rightarrow M_2 \rightarrow D$, dove $M_1$ e $M_2$ sono i nodi controllati da un'eventuale entità malevola, $M_1$ riceverà in entrata il pacchetto da $A$ al tempo $t_1$, e grazie all'Onion Routing non può sapere quale nodo sarà la destinazione finale. Successivamente il nodo $M_2$ riceverà un pacchetto dal nodo $C$ al tempo $t_2$ e lo consegnerà a $D$, sempre grazie all'Onion Routing $M_2$ non è in grado di conosce il mittente del pagamento.

Tuttavia, nel caso in cui i nodi $M$ raccogliessero i dati, l'entità malevola può notare che la differenza $\Delta t = t_2 - t_1$ corrisponde esattamente al tempo di rete necessario per attraversare i nodi intermedi $B$ e $C$. Se il traffico della rete non è elevato, questa coincidenza temporale permette all'entità di affermare che, con una probabilità molto alta, i due eventi appartengono allo stesso flusso. In questo modo scoprirà che $A$ sta pagando $D$, e la transazione non sarà più anonima. \cite{antonopoulos2022masteringLN}.
%----------------------------------------------------------------------------------------
\chapter{Limiti del Lightning Network e sviluppi futuri}
%----------------------------------------------------------------------------------------
Nonostante i vantaggi, il Lightning Network presenta ancora diversi limiti e criticità.

\section{Topologia della rete e problemi di centralizzazione}
\section{Vulnerabilità e attacchi}
\section{Proposte di miglioramento e linee di ricerca}

%----------------------------------------------------------------------------------------
\chapter*{Conclusioni}
\addcontentsline{toc}{chapter}{Conclusioni}
%----------------------------------------------------------------------------------------
In questa tesi è stato analizzato il Lightning Network come possibile soluzione al problema della scalabilità...

%----------------------------------------------------------------------------------------
% BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\backmatter
\bibliographystyle{alpha}
\bibliography{bibliography}

\end{document}